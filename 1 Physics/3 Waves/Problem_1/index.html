<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/3 Waves/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2 - Escape &amp; Cosmic Velocities Simulation</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3 - Trajectories of a Freely Released Payload Near Earth</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">3 Waves</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">3 Waves</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="interference-patterns-on-a-water-surface">Interference Patterns on a Water Surface</h1>
<h2 id="1-motivation">1. Motivation</h2>
<p>Interference occurs when waves from different sources overlap and form distinct ripple patterns on a surface. On a water surface, these interference patterns can be easily visualized when circular ripples emitted from different points interact.</p>
<p>Understanding how wave phase, wavelength, frequency, and source geometry influence these patterns offers deep insight into wave behavior. This experiment also demonstrates constructive interference (amplification) and destructive interference (cancellation), which are fundamental to fields like acoustics, optics, and quantum physics.</p>
<hr/>
<h2 id="2-task-description">2. Task Description</h2>
<p>We will study interference patterns generated by wave sources placed at the vertices of a <strong>regular polygon</strong> (such as a triangle, square, or pentagon). The waves are assumed to be:</p>
<ul>
<li>Coherent (same frequency and phase offset),</li>
<li>Equal in amplitude and wavelength,</li>
<li>Emitted at the same time from their respective sources.</li>
</ul>
<p>The objective is to visualize the resulting interference patterns on the surface of water.</p>
<hr/>
<h2 id="3-mathematical-model">3. Mathematical Model</h2>
<h3 id="31-single-source-wave-equation">3.1. Single Source Wave Equation</h3>
<p>The disturbance from a single point source located at <span class="arithmatex">\( (x_0, y_0) \)</span> is given by:</p>
<div class="arithmatex">\[
\eta(x, y, t) = \frac{A}{\sqrt{r}} \cdot \cos(kr - \omega t + \phi)
\]</div>
<p>Where:</p>
<ul>
<li><span class="arithmatex">\( A \)</span>: amplitude  </li>
<li><span class="arithmatex">\( k = \frac{2\pi}{\lambda} \)</span>: wave number (λ is wavelength)  </li>
<li><span class="arithmatex">\( \omega = 2\pi f \)</span>: angular frequency  </li>
<li><span class="arithmatex">\( r = \sqrt{(x - x_0)^2 + (y - y_0)^2} \)</span>: distance from source  </li>
<li><span class="arithmatex">\( \phi \)</span>: initial phase  </li>
<li><span class="arithmatex">\( t \)</span>: time  </li>
</ul>
<hr/>
<h3 id="32-superposition-of-waves">3.2. Superposition of Waves</h3>
<p>For <span class="arithmatex">\( N \)</span> sources located at different positions, the total displacement is:</p>
<div class="arithmatex">\[
\eta_{\text{sum}}(x, y, t) = \sum_{i=1}^{N} \eta_i(x, y, t)
\]</div>
<p>This is the principle of <strong>superposition</strong>, where all disturbances are added point-wise.</p>
<hr/>
<h2 id="4-simulation-code">4. Simulation Code</h2>
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Wave Interference Pattern Simulation</title>
<style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      margin: 0;
      padding: 20px;
      color: #333;
      line-height: 1.6;
      max-width: 1000px;
      margin: 0 auto;
    }

    h1, h2 {
      color: #2c3e50;
      text-align: center;
    }

    .container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 20px;
      margin: 20px 0;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }

    canvas {
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #000;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
    }

    label {
      margin-bottom: 5px;
      font-weight: bold;
    }

    input, select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    button {
      background-color: #4c6ef5;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #364fc7;
    }

    .info {
      background-color: #f0f4f8;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }

    .equation {
      text-align: center;
      margin: 15px 0;
      font-style: italic;
    }

    .color-scale {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 20px 0;
    }

    .color-bar {
      width: 300px;
      height: 20px;
      background: linear-gradient(to right, blue, white, red);
      border-radius: 2px;
      margin: 0 10px;
    }

    .scale-label {
      font-size: 14px;
      color: #666;
    }

    .footnote {
      margin-top: 30px;
      font-size: 0.9em;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
<h1>Wave Interference Pattern Simulation</h1>
<div class="container">
<div class="info">
<p>This simulation demonstrates the interference pattern created by multiple wave sources arranged in a regular polygon. The wave amplitude at each point is calculated by summing the contributions from all sources, considering distance-dependent amplitude decay and phase differences.</p>
<div class="equation">
        η(x,y) = ∑ A/√R · cos(kR - ωt + φ)
      </div>
<p>Where:</p>
<ul>
<li>η is the wave displacement</li>
<li>A is the amplitude</li>
<li>R is the distance from source</li>
<li>k is the wave number (2π/λ)</li>
<li>ω is the angular frequency</li>
<li>t is time</li>
<li>φ is the phase constant</li>
</ul>
</div>
<div class="controls">
<div class="control-group">
<label for="amplitude">Amplitude (A):</label>
<input id="amplitude" max="2" min="0.1" step="0.1" type="range" value="1.0"/>
<span id="ampValue">1.0</span>
</div>
<div class="control-group">
<label for="wavelength">Wavelength (λ):</label>
<input id="wavelength" max="5" min="0.5" step="0.1" type="range" value="2.0"/>
<span id="waveValue">2.0</span>
</div>
<div class="control-group">
<label for="sources">Number of Sources:</label>
<select id="sources">
<option value="3">3 (Triangle)</option>
<option selected="" value="4">4 (Square)</option>
<option value="5">5 (Pentagon)</option>
<option value="6">6 (Hexagon)</option>
<option value="8">8 (Octagon)</option>
</select>
</div>
<div class="control-group">
<label for="radius">Source Radius:</label>
<input id="radius" max="6" min="1" step="0.5" type="range" value="3"/>
<span id="radiusValue">3.0</span>
</div>
</div>
<button id="updateBtn">Update Simulation</button>
<div class="canvas-container">
<canvas height="600" id="interferenceCanvas" width="600"></canvas>
</div>
<div class="color-scale">
<span class="scale-label">Negative</span>
<div class="color-bar"></div>
<span class="scale-label">Positive</span>
</div>
</div>
<div class="footnote">
<p>© 2025 Wave Interference Pattern Simulation</p>
</div>
<script>
    // Get canvas and context
    const canvas = document.getElementById('interferenceCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const amplitudeInput = document.getElementById('amplitude');
    const wavelengthInput = document.getElementById('wavelength');
    const sourcesInput = document.getElementById('sources');
    const radiusInput = document.getElementById('radius');
    const updateBtn = document.getElementById('updateBtn');
    const ampValue = document.getElementById('ampValue');
    const waveValue = document.getElementById('waveValue');
    const radiusValue = document.getElementById('radiusValue');

    // Set up simulation parameters
    let A = parseFloat(amplitudeInput.value);           // Amplitude
    let wavelength = parseFloat(wavelengthInput.value); // Wavelength
    let numSources = parseInt(sourcesInput.value);      // Number of sources
    let sourceRadius = parseFloat(radiusInput.value);   // Radius of source arrangement
    let frequency = 1.0;                               // Frequency (fixed)
    let k = 2 * Math.PI / wavelength;                  // Wave number
    let omega = 2 * Math.PI * frequency;               // Angular frequency
    let phi = 0;                                       // Phase constant
    let t = 0;                                         // Time snapshot

    // Display initial values
    ampValue.textContent = A.toFixed(1);
    waveValue.textContent = wavelength.toFixed(1);
    radiusValue.textContent = sourceRadius.toFixed(1);

    // Event listeners for UI elements
    amplitudeInput.addEventListener('input', function() {
      A = parseFloat(this.value);
      ampValue.textContent = A.toFixed(1);
    });

    wavelengthInput.addEventListener('input', function() {
      wavelength = parseFloat(this.value);
      k = 2 * Math.PI / wavelength;
      waveValue.textContent = wavelength.toFixed(1);
    });

    radiusInput.addEventListener('input', function() {
      sourceRadius = parseFloat(this.value);
      radiusValue.textContent = sourceRadius.toFixed(1);
    });

    updateBtn.addEventListener('click', runSimulation);

    // Generate polygon source points
    function regularPolygon(n, radius) {
      const points = [];
      for (let i = 0; i < n; i++) {
        const x = radius * Math.cos(2 * Math.PI * i / n);
        const y = radius * Math.sin(2 * Math.PI * i / n);
        points.push([x, y]);
      }
      return points;
    }

    // Function to map values from wave amplitude to colormap
    function mapToColor(value, min, max) {
      // Normalize to 0-1
      const normalized = (value - min) / (max - min);

      // Map to RGB (blue - white - red)
      let r, g, b;

      if (normalized < 0.5) {
        // Blue to white (0 to 0.5)
        const t = normalized * 2;
        r = 255 * t;
        g = 255 * t;
        b = 255;
      } else {
        // White to red (0.5 to 1)
        const t = (normalized - 0.5) * 2;
        r = 255;
        g = 255 * (1 - t);
        b = 255 * (1 - t);
      }

      return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
    }

    // Run the simulation
    function runSimulation() {
      // Update parameters
      numSources = parseInt(sourcesInput.value);
      k = 2 * Math.PI / wavelength;

      // Get canvas dimensions
      const width = canvas.width;
      const height = canvas.height;

      // Create image data
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      // Generate source positions
      const sources = regularPolygon(numSources, sourceRadius);

      // Scale factors for mapping canvas to computational grid
      const scale = 20; // This determines the "zoom" level
      const offsetX = width / 2;
      const offsetY = height / 2;

      // Calculate wave values
      let minVal = Infinity;
      let maxVal = -Infinity;
      const waveValues = new Array(width * height);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // Convert canvas coordinates to physical coordinates
          const physX = (x - offsetX) / scale;
          const physY = (y - offsetY) / scale;

          // Calculate total wave amplitude from all sources
          let eta = 0;
          for (const [x0, y0] of sources) {
            const R = Math.sqrt((physX - x0) ** 2 + (physY - y0) ** 2);
            // Avoid division by zero
            const amplitude = R < 0.01 ? A : A / Math.sqrt(R + 0.01);
            eta += amplitude * Math.cos(k * R - omega * t + phi);
          }

          // Store value and track min/max
          const index = y * width + x;
          waveValues[index] = eta;
          minVal = Math.min(minVal, eta);
          maxVal = Math.max(maxVal, eta);
        }
      }

      // Render image
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = y * width + x;
          const eta = waveValues[index];
          const color = mapToColor(eta, minVal, maxVal);

          // Parse RGB values from the color string
          const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          const r = parseInt(match[1]);
          const g = parseInt(match[2]);
          const b = parseInt(match[3]);

          // Set pixel data (4 bytes per pixel: R, G, B, A)
          const pixelIndex = (y * width + x) * 4;
          data[pixelIndex] = r;
          data[pixelIndex + 1] = g;
          data[pixelIndex + 2] = b;
          data[pixelIndex + 3] = 255;  // Alpha (opaque)
        }
      }

      // Draw the image data to the canvas
      ctx.putImageData(imageData, 0, 0);

      // Draw source positions
      drawSources(sources, scale, offsetX, offsetY);
    }

    // Draw the source positions on the canvas
    function drawSources(sources, scale, offsetX, offsetY) {
      ctx.fillStyle = 'white';
      ctx.strokeStyle = 'black';

      for (const [x0, y0] of sources) {
        const canvasX = x0 * scale + offsetX;
        const canvasY = y0 * scale + offsetY;

        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
    }

    // Initial simulation
    runSimulation();
  </script>
</body>
</html>
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Interference Pattern from Polygon Sources</title>
<style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f7fa;
      color: #333;
      line-height: 1.6;
      max-width: 1000px;
      margin: 0 auto;
    }

    h1, h2 {
      color: #2c3e50;
      text-align: center;
      margin-top: 1.5em;
    }

    .container {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 20px;
      margin: 20px 0;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }

    canvas {
      display: block;
      margin: 0 auto;
      border: 1px solid #ddd;
      border-radius: 5px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      margin: 20px 0;
    }

    .control-group {
      flex: 1;
      min-width: 200px;
      max-width: 250px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 5px;
    }

    input, select {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .button-group {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      background-color: #4c6ef5;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #364fc7;
    }

    .parameter-display {
      background-color: #f0f4f8;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }

    .equation {
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin: 15px 0;
      font-style: italic;
      text-align: center;
    }

    .legend {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 15px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 0 10px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .colormap {
      height: 20px;
      width: 100%;
      margin: 10px 0;
      background: linear-gradient(to right,
        #440154, #482878, #3e4989, #31688e, #26828e, 
        #1f9e89, #35b779, #6ece58, #b5de2b, #fde725);
      border-radius: 3px;
    }

    .colormap-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.85em;
      color: #666;
    }

    .footnote {
      margin-top: 30px;
      font-size: 0.9em;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
<h1>Interference Pattern from Polygon Wave Sources</h1>
<div class="container">
<div class="parameter-display">
<h2>Wave Physics Simulation</h2>
<p>This simulation demonstrates the interference pattern created when multiple point sources of waves are arranged at the vertices of a regular polygon. The total wave amplitude at any point is calculated as the sum of contributions from each source.</p>
<div class="equation">
        η(x,y) = ∑ (A / √r) · cos(kr - ωt + φ)
      </div>
<p>Where:</p>
<ul>
<li>A = amplitude of each source</li>
<li>r = distance from the source to the point (x,y)</li>
<li>k = wave number (2π/λ)</li>
<li>ω = angular frequency (2πf)</li>
<li>t = time</li>
<li>φ = initial phase</li>
</ul>
</div>
<div class="controls">
<div class="control-group">
<label for="polygonVertices">Number of Sources:</label>
<select id="polygonVertices">
<option value="3">3 (Triangle)</option>
<option value="4">4 (Square)</option>
<option value="5">5 (Pentagon)</option>
<option selected="" value="6">6 (Hexagon)</option>
<option value="8">8 (Octagon)</option>
<option value="12">12 (Dodecagon)</option>
</select>
<label for="amplitude">Amplitude (A):</label>
<input id="amplitude" max="2" min="0.1" step="0.1" type="range" value="1"/>
<span id="amplitudeValue">1.0</span>
<label for="wavelength">Wavelength (λ):</label>
<input id="wavelength" max="5" min="0.5" step="0.1" type="range" value="2"/>
<span id="wavelengthValue">2.0</span>
</div>
<div class="control-group">
<label for="radius">Polygon Radius:</label>
<input id="radius" max="8" min="1" step="0.5" type="range" value="5"/>
<span id="radiusValue">5.0</span>
<label for="resolution">Resolution:</label>
<select id="resolution">
<option value="100">Low</option>
<option selected="" value="200">Medium</option>
<option value="300">High</option>
</select>
<label for="colormap">Color Map:</label>
<select id="colormap">
<option selected="" value="viridis">Viridis</option>
<option value="plasma">Plasma</option>
<option value="inferno">Inferno</option>
<option value="magma">Magma</option>
<option value="rdbu">Red-Blue</option>
</select>
</div>
</div>
<div class="button-group">
<button id="calculateBtn">Calculate Interference Pattern</button>
</div>
<div class="canvas-container">
<canvas height="600" id="interferenceCanvas" width="600"></canvas>
</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color" style="background-color: red;"></div>
<span>Wave Sources</span>
</div>
</div>
<div>
<p>Displacement Color Scale:</p>
<div class="colormap" id="colormapDisplay"></div>
<div class="colormap-labels">
<span>Minimum</span>
<span>Maximum</span>
</div>
</div>
</div>
<div class="footnote">
<p>© 2025 Wave Interference Physics Simulation | For educational purposes</p>
</div>
<script>
    // Get DOM elements
    const canvas = document.getElementById('interferenceCanvas');
    const ctx = canvas.getContext('2d');
    const calculateBtn = document.getElementById('calculateBtn');

    const polygonSelect = document.getElementById('polygonVertices');
    const amplitudeInput = document.getElementById('amplitude');
    const wavelengthInput = document.getElementById('wavelength');
    const radiusInput = document.getElementById('radius');
    const resolutionSelect = document.getElementById('resolution');
    const colormapSelect = document.getElementById('colormap');

    const amplitudeValue = document.getElementById('amplitudeValue');
    const wavelengthValue = document.getElementById('wavelengthValue');
    const radiusValue = document.getElementById('radiusValue');

    // Initial parameter values
    let A = 1.0;                // Amplitude
    let wavelength = 2.0;       // Wavelength
    let frequency = 1.0;        // Frequency (fixed)
    let omega = 2 * Math.PI * frequency;
    let k = 2 * Math.PI / wavelength;
    let phi = 0;                // Initial phase
    let t = 0;                  // Time snapshot (fixed)
    let N = 6;                  // Number of sources
    let radius = 5.0;           // Polygon radius
    let resolution = 200;       // Grid resolution
    let colormap = 'viridis';   // Default colormap

    // Update displayed values
    amplitudeInput.addEventListener('input', () => {
      A = parseFloat(amplitudeInput.value);
      amplitudeValue.textContent = A.toFixed(1);
    });

    wavelengthInput.addEventListener('input', () => {
      wavelength = parseFloat(wavelengthInput.value);
      wavelengthValue.textContent = wavelength.toFixed(1);
      k = 2 * Math.PI / wavelength;
    });

    radiusInput.addEventListener('input', () => {
      radius = parseFloat(radiusInput.value);
      radiusValue.textContent = radius.toFixed(1);
    });

    // Update resolution when selected
    resolutionSelect.addEventListener('change', () => {
      resolution = parseInt(resolutionSelect.value);
    });

    // Update number of sources when changed
    polygonSelect.addEventListener('change', () => {
      N = parseInt(polygonSelect.value);
    });

    // Update colormap when selected
    colormapSelect.addEventListener('change', () => {
      colormap = colormapSelect.value;
      updateColormapDisplay();
    });

    // Color maps
    const colormaps = {
      viridis: [
        [68, 1, 84], [70, 50, 126], [54, 92, 141], [39, 127, 142], 
        [31, 161, 135], [74, 194, 109], [159, 218, 58], [253, 231, 37]
      ],
      plasma: [
        [13, 8, 135], [75, 0, 160], [125, 0, 168], [168, 0, 157], 
        [203, 32, 107], [224, 80, 66], [239, 140, 45], [246, 211, 47]
      ],
      inferno: [
        [0, 0, 4], [40, 11, 84], [101, 21, 110], [159, 42, 99], 
        [212, 72, 66], [241, 130, 37], [250, 193, 39], [252, 255, 164]
      ],
      magma: [
        [0, 0, 4], [44, 13, 74], [104, 26, 107], [168, 49, 96], 
        [216, 80, 72], [244, 131, 44], [254, 190, 65], [252, 253, 191]
      ],
      rdbu: [
        [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], 
        [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172]
      ]
    };

    // Update colormap display
    function updateColormapDisplay() {
      const colormapDiv = document.getElementById('colormapDisplay');
      const colors = colormaps[colormap];

      let gradientString = 'linear-gradient(to right';
      for (let i = 0; i < colors.length; i++) {
        const percent = (i / (colors.length - 1)) * 100;
        const [r, g, b] = colors[i];
        gradientString += `, rgb(${r}, ${g}, ${b}) ${percent}%`;
      }
      gradientString += ')';

      colormapDiv.style.background = gradientString;
    }

    // Generate points for a regular polygon
    function generatePolygonPoints(n, r) {
      const points = [];
      for (let i = 0; i < n; i++) {
        const angle = (i * 2 * Math.PI) / n;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        points.push([x, y]);
      }
      return points;
    }

    // Map a value from one range to another
    function mapValue(value, inMin, inMax, outMin, outMax) {
      return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }

    // Get color from colormap
    function getColor(value, min, max, map = colormap) {
      // Normalize value to 0-1 range
      const normalized = (value - min) / (max - min);

      // Clamp to 0-1
      const clamped = Math.max(0, Math.min(1, normalized));

      // Get color map
      const colors = colormaps[map];

      // Find position in colormap
      const position = clamped * (colors.length - 1);
      const index = Math.floor(position);
      const fraction = position - index;

      // Handle edge cases
      if (index >= colors.length - 1) {
        return `rgb(${colors[colors.length - 1][0]}, ${colors[colors.length - 1][1]}, ${colors[colors.length - 1][2]})`;
      }

      // Interpolate between colors
      const c1 = colors[index];
      const c2 = colors[index + 1];

      const r = Math.round(c1[0] + fraction * (c2[0] - c1[0]));
      const g = Math.round(c1[1] + fraction * (c2[1] - c1[1]));
      const b = Math.round(c1[2] + fraction * (c2[2] - c1[2]));

      return `rgb(${r}, ${g}, ${b})`;
    }

    // Calculate and draw the interference pattern
    function calculateInterferencePattern() {
      // Update parameters from inputs
      A = parseFloat(amplitudeInput.value);
      wavelength = parseFloat(wavelengthInput.value);
      k = 2 * Math.PI / wavelength;
      N = parseInt(polygonSelect.value);
      radius = parseFloat(radiusInput.value);
      resolution = parseInt(resolutionSelect.value);
      colormap = colormapSelect.value;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Generate source positions
      const sourcePoints = generatePolygonPoints(N, radius);

      // Create a pixel-by-pixel image
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;

      // Create scaling factors to map between canvas and simulation coordinates
      const scale = 20; // Adjust this to zoom in/out
      const offsetX = canvas.width / 2;
      const offsetY = canvas.height / 2;

      // Store the wave values to find min/max for normalization
      let waveValues = [];
      let minVal = Infinity;
      let maxVal = -Infinity;

      // Calculate wave values first to find min/max
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          // Convert canvas coordinates to simulation coordinates
          const simX = (x - offsetX) / scale;
          const simY = (y - offsetY) / scale;

          // Calculate total amplitude from all sources
          let etaTotal = 0;
          for (const [x0, y0] of sourcePoints) {
            const r = Math.sqrt((simX - x0) ** 2 + (simY - y0) ** 2) + 1e-6; // Avoid division by zero
            const sourceContribution = (A / Math.sqrt(r)) * Math.cos(k * r - omega * t + phi);
            etaTotal += sourceContribution;
          }

          // Store value and track min/max
          waveValues.push(etaTotal);
          minVal = Math.min(minVal, etaTotal);
          maxVal = Math.max(maxVal, etaTotal);
        }
      }

      // Now set the pixel values with normalized colors
      let index = 0;
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const pixelIndex = (y * canvas.width + x) * 4;
          const etaTotal = waveValues[index++];

          // Get color from colormap
          const color = getColor(etaTotal, minVal, maxVal);

          // Parse RGB components from the color string
          const rgb = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

          // Set pixel data
          data[pixelIndex] = parseInt(rgb[1]);     // Red
          data[pixelIndex + 1] = parseInt(rgb[2]); // Green
          data[pixelIndex + 2] = parseInt(rgb[3]); // Blue
          data[pixelIndex + 3] = 255;              // Alpha (fully opaque)
        }
      }

      // Put the image data on the canvas
      ctx.putImageData(imageData, 0, 0);

      // Draw the source points
      for (const [x0, y0] of sourcePoints) {
        const canvasX = x0 * scale + offsetX;
        const canvasY = y0 * scale + offsetY;

        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // Initial setup
    updateColormapDisplay();
    calculateBtn.addEventListener('click', calculateInterferencePattern);
    // Calculate on page load
    window.addEventListener('load', calculateInterferencePattern);
  </script>
</body>
</html>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../2%20Gravity/Problem_3/" title="Problem 3 - Trajectories of a Freely Released Payload Near Earth"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../2%20Gravity/Problem_3/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
