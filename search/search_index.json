{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis 1. Theoretical Foundation Deriving Equations of Motion Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\] Family of Solutions Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges. 2. Analysis of the Range The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Factors Affecting Range Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) . 3. Practical Applications Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity. 4. Implementation Simulation Simulation Parameters Initial Velocity (m/s): 20 Launch Angle (degrees): 45 Gravity (m/s\u00b2): 9.81 Initial Height (m): 0 Air Resistance Coefficient: 0 Run Simulation 0.00 Range (m) 0.00 Max Height (m) 0.00 Flight Time (s) Trajectory Visualization Range vs. Launch Angle Analysis Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0. // Get DOM elements const initialVelocitySlider = document.getElementById('initial-velocity'); const launchAngleSlider = document.getElementById('launch-angle'); const gravitySlider = document.getElementById('gravity'); const initialHeightSlider = document.getElementById('initial-height'); const airResistanceSlider = document.getElementById('air-resistance'); const velocityValue = document.getElementById('velocity-value'); const angleValue = document.getElementById('angle-value'); const gravityValue = document.getElementById('gravity-value'); const heightValue = document.getElementById('height-value'); const resistanceValue = document.getElementById('resistance-value'); const rangeValue = document.getElementById('range-value'); const maxHeightValue = document.getElementById('max-height-value'); const timeValue = document.getElementById('time-value'); const simulateBtn = document.getElementById('simulate-btn'); const trajectoryCanvas = document.getElementById('trajectory-canvas'); const rangeAngleCanvas = document.getElementById('range-angle-canvas'); const optimalAngleInfo = document.getElementById('optimal-angle-info'); // Canvas setup const trajCtx = trajectoryCanvas.getContext('2d'); const rangeCtx = rangeAngleCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { trajectoryCanvas.width = trajectoryCanvas.clientWidth; trajectoryCanvas.height = trajectoryCanvas.clientHeight; rangeAngleCanvas.width = rangeAngleCanvas.clientWidth; rangeAngleCanvas.height = rangeAngleCanvas.clientHeight; } window.addEventListener('resize', resizeCanvas); resizeCanvas(); // Display slider values initialVelocitySlider.addEventListener('input', () => { velocityValue.textContent = initialVelocitySlider.value; }); launchAngleSlider.addEventListener('input', () => { angleValue.textContent = launchAngleSlider.value; }); gravitySlider.addEventListener('input', () => { gravityValue.textContent = parseFloat(gravitySlider.value).toFixed(2); }); initialHeightSlider.addEventListener('input', () => { heightValue.textContent = initialHeightSlider.value; }); airResistanceSlider.addEventListener('input', () => { resistanceValue.textContent = parseFloat(airResistanceSlider.value).toFixed(2); }); // Simulation calculations function calculateTrajectory(v0, angle, gravity, height, airResistance) { // Convert angle to radians const angleRad = angle * Math.PI / 180; // Initial velocities const vx0 = v0 * Math.cos(angleRad); const vy0 = v0 * Math.sin(angleRad); let flightTime; let x = []; let y = []; // Calculate flight time (analytical solution without air resistance) if (airResistance === 0) { flightTime = (vy0 + Math.sqrt(vy0 * vy0 + 2 * gravity * height)) / gravity; // Handle very small angles with initial height if (angle < 0.1 && height > 0) { flightTime = (2 * vy0) / gravity + Math.sqrt(2 * height / gravity); } // Time steps for trajectory const timeSteps = 1000; const dt = flightTime / timeSteps; // Analytical calculation for (let i = 0; i <= timeSteps; i++) { const t = i * dt; x.push(vx0 * t); y.push(height + vy0 * t - 0.5 * gravity * t * t); // Stop if we hit the ground if (y[i] < 0) { y[i] = 0; x = x.slice(0, i + 1); y = y.slice(0, i + 1); break; } } } else { // Numerical calculation with air resistance const dt = 0.01; let t = 0; let yPos = height; let xPos = 0; let vx = vx0; let vy = vy0; while (yPos >= 0) { // Update velocities vx = vx - airResistance * vx * dt; vy = vy - gravity * dt - airResistance * vy * dt; // Update position xPos = xPos + vx * dt; yPos = yPos + vy * dt; x.push(xPos); y.push(yPos); t += dt; // Avoid infinite loops or extremely long calculations if (t > 100 || xPos > 10000) break; } flightTime = t; // Fix the last point if (y[y.length - 1] < 0) { y[y.length - 1] = 0; } } // Calculate range const horizontalRange = x[x.length - 1]; // Calculate maximum height let maxHeight = height; for (let i = 0; i < y.length; i++) { if (y[i] > maxHeight) { maxHeight = y[i]; } } return { x: x, y: y, range: horizontalRange, maxHeight: maxHeight, flightTime: flightTime }; } // Generate range vs angle chart function generateRangeVsAngleChart(v0, gravity, height) { const angles = []; const ranges = []; // Calculate range for each angle for (let angle = 0; angle <= 90; angle += 1) { angles.push(angle); const traj = calculateTrajectory(v0, angle, gravity, height, 0); ranges.push(traj.range); } // Find maximum range let maxRange = 0; let maxAngle = 0; for (let i = 0; i < ranges.length; i++) { if (ranges[i] > maxRange) { maxRange = ranges[i]; maxAngle = angles[i]; } } return { angles: angles, ranges: ranges, maxRange: maxRange, maxAngle: maxAngle }; } // Draw trajectory graph function drawTrajectory(data) { const canvas = trajectoryCanvas; const ctx = trajCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xMax = Math.max(...data.x) * 1.1; const yMax = Math.max(data.maxHeight * 1.2, 10); const xScale = plotWidth / xMax; const yScale = plotHeight / yMax; // Ground line ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Horizontal Distance (m)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Height (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= xMax; x += xMax / 5) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(Math.round(x).toString(), xPos, canvas.height - marginY + 15); } // Y axis values for (let y = 0; y <= yMax; y += yMax / 5) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw trajectory ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; for (let i = 0; i < data.x.length; i++) { const xPos = marginX + data.x[i] * xScale; const yPos = canvas.height - marginY - data.y[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Starting point ctx.beginPath(); ctx.fillStyle = '#e74c3c'; ctx.arc(marginX, canvas.height - marginY - data.y[0] * yScale, 5, 0, 2 * Math.PI); ctx.fill(); // Highest point const maxHeightIndex = data.y.indexOf(data.maxHeight); const maxHeightX = data.x[maxHeightIndex]; ctx.beginPath(); ctx.fillStyle = '#27ae60'; ctx.arc( marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Landing point ctx.beginPath(); ctx.fillStyle = '#9b59b6'; ctx.arc( marginX + data.x[data.x.length - 1] * xScale, canvas.height - marginY - data.y[data.y.length - 1] * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Labels ctx.font = '12px Arial'; ctx.fillStyle = '#333'; // Start label ctx.textAlign = 'left'; ctx.fillText('Start', marginX + 10, canvas.height - marginY - data.y[0] * yScale - 10); // Peak label ctx.textAlign = 'center'; ctx.fillText( `Peak: ${data.maxHeight.toFixed(2)}m`, marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale - 10 ); // Range label ctx.textAlign = 'right'; ctx.fillText( `Range: ${data.range.toFixed(2)}m`, marginX + data.x[data.x.length - 1] * xScale - 10, canvas.height - marginY - data.y[data.y.length - 1] * yScale - 10 ); } // Draw range vs angle chart function drawRangeVsAngleChart(data) { const canvas = rangeAngleCanvas; const ctx = rangeCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xScale = plotWidth / 90; const yScale = plotHeight / (data.maxRange * 1.1); // X axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Launch Angle (degrees)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Range (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= 90; x += 15) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(x.toString(), xPos, canvas.height - marginY + 15); } // Y axis values const yStep = data.maxRange / 5; for (let y = 0; y <= data.maxRange; y += yStep) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw chart ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; for (let i = 0; i < data.angles.length; i++) { const xPos = marginX + data.angles[i] * xScale; const yPos = canvas.height - marginY - data.ranges[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Mark maximum point const maxXPos = marginX + data.maxAngle * xScale; const maxYPos = canvas.height - marginY - data.maxRange * yScale; ctx.beginPath(); ctx.fillStyle = '#2980b9'; ctx.arc(maxXPos, maxYPos, 5, 0, 2 * Math.PI); ctx.fill(); // Maximum label ctx.font = '12px Arial'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.fillText( `Max Range: ${data.maxRange.toFixed(2)}m at ${data.maxAngle.toFixed(1)}\u00b0`, maxXPos, maxYPos - 10 ); } // Run simulation function runSimulation() { // Get parameters const v0 = parseFloat(initialVelocitySlider.value); const angle = parseFloat(launchAngleSlider.value); const gravity = parseFloat(gravitySlider.value); const height = parseFloat(initialHeightSlider.value); const airResistance = parseFloat(airResistanceSlider.value); // Calculate trajectory const trajData = calculateTrajectory(v0, angle, gravity, height, airResistance); // Update metrics rangeValue.textContent = trajData.range.toFixed(2); maxHeightValue.textContent = trajData.maxHeight.toFixed(2); timeValue.textContent = trajData.flightTime.toFixed(2); // Draw trajectory graph drawTrajectory(trajData); // Calculate and draw range vs angle chart const rangeAngleData = generateRangeVsAngleChart(v0, gravity, height); drawRangeVsAngleChart(rangeAngleData); // Update optimal angle info if (height === 0 && airResistance === 0) { optimalAngleInfo.textContent = \"Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0.\"; } else if (height > 0 && airResistance === 0) { optimalAngleInfo.textContent = \"With initial height, the optimal launch angle for maximum range is slightly less than 45\u00b0.\"; } else if (airResistance > 0) { optimalAngleInfo.textContent = \"With air resistance, the optimal launch angle is typically less than 45\u00b0 and depends on the projectile's properties.\"; } } // Simulate button click event simulateBtn.addEventListener('click', runSimulation); // Run initial simulation when page loads window.addEventListener('load', runSimulation);","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-equations-of-motion","text":"Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Deriving Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\]","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#factors-affecting-range","text":"Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) .","title":"Factors Affecting Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation","text":"","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Projectile Motion Analysis 1. Theoretical Foundation Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 2. Simulation Example Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$ Trajectory Table Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74 3. Optional: Interactive Simulation Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; } Forced Damped Pendulum Simulation and Analysis Simulation Parameters Damping Coefficient (\u03b3) 0.50 Driving Amplitude (A) 1.20 Driving Frequency (\u03c9) 0.67 Natural Frequency (\u03c9\u2080) 1.00 Initial Angle (\u03b8\u2080) 0.20 Initial Angular Velocity (\u03b8\u0307\u2080) 0.00 Run Simulation Pendulum Visualization d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) This simulation demonstrates the behavior of a forced damped pendulum. Adjust the parameters to observe how the pendulum responds under different conditions, from periodic motion to chaotic behavior. Angular Displacement vs Time Shows how the pendulum angle changes over time, revealing periodic or chaotic patterns. Phase Space Plots angular velocity against angle, showing the system's overall dynamic behavior. Poincar\u00e9 Section Samples the phase space at regular intervals synchronized with the driving force, revealing long-term behavior patterns and potential chaos. \u00a9 2025 Physics Simulation Project // Get DOM elements const pendulumCanvas = document.getElementById('pendulum-canvas'); const timeChart = document.getElementById('time-chart'); const phaseChart = document.getElementById('phase-chart'); const poincareChart = document.getElementById('poincare-chart'); const runBtn = document.getElementById('run-btn'); // Set up canvas contexts const pendulumCtx = pendulumCanvas.getContext('2d'); const timeCtx = timeChart.getContext('2d'); const phaseCtx = phaseChart.getContext('2d'); const poincareCtx = poincareChart.getContext('2d'); // Set proper canvas sizes function setupCanvases() { // Set pendulum canvas size pendulumCanvas.width = pendulumCanvas.offsetWidth; pendulumCanvas.height = pendulumCanvas.offsetHeight; // Set chart canvas sizes timeChart.width = timeChart.offsetWidth; timeChart.height = timeChart.offsetHeight; phaseChart.width = phaseChart.offsetWidth; phaseChart.height = phaseChart.offsetHeight; poincareChart.width = poincareChart.offsetWidth; poincareChart.height = poincareChart.offsetHeight; } // Call setupCanvases when the page loads and on window resize window.addEventListener('load', setupCanvases); window.addEventListener('resize', setupCanvases); // Simulation parameters let gamma = 0.5; // damping coefficient let A = 1.2; // driving amplitude let omega = 0.67; // driving frequency let omega0 = 1.0; // natural frequency let theta0 = 0.2; // initial angle let thetaDot0 = 0.0; // initial angular velocity // Connect sliders to values document.getElementById('gamma').addEventListener('input', function() { gamma = parseFloat(this.value); document.getElementById('gamma-value').textContent = gamma.toFixed(2); }); document.getElementById('amplitude').addEventListener('input', function() { A = parseFloat(this.value); document.getElementById('amplitude-value').textContent = A.toFixed(2); }); document.getElementById('omega').addEventListener('input', function() { omega = parseFloat(this.value); document.getElementById('omega-value').textContent = omega.toFixed(2); }); document.getElementById('omega0').addEventListener('input', function() { omega0 = parseFloat(this.value); document.getElementById('omega0-value').textContent = omega0.toFixed(2); }); document.getElementById('theta0').addEventListener('input', function() { theta0 = parseFloat(this.value); document.getElementById('theta0-value').textContent = theta0.toFixed(2); }); document.getElementById('thetaDot0').addEventListener('input', function() { thetaDot0 = parseFloat(this.value); document.getElementById('thetaDot0-value').textContent = thetaDot0.toFixed(2); }); // Simulation data let simData = []; let poincareData = []; let animationId = null; // ODE for pendulum function pendulumODE(t, theta, thetaDot) { // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) return -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); } // RK4 method for solving ODEs function rungeKutta4(t, theta, thetaDot, dt) { const k1_v = thetaDot; const k1_a = pendulumODE(t, theta, thetaDot); const k2_v = thetaDot + k1_a * dt/2; const k2_a = pendulumODE(t + dt/2, theta + k1_v * dt/2, thetaDot + k1_a * dt/2); const k3_v = thetaDot + k2_a * dt/2; const k3_a = pendulumODE(t + dt/2, theta + k2_v * dt/2, thetaDot + k2_a * dt/2); const k4_v = thetaDot + k3_a * dt; const k4_a = pendulumODE(t + dt, theta + k3_v * dt, thetaDot + k3_a * dt); const new_theta = theta + (dt/6) * (k1_v + 2*k2_v + 2*k3_v + k4_v); const new_thetaDot = thetaDot + (dt/6) * (k1_a + 2*k2_a + 2*k3_a + k4_a); return [new_theta, new_thetaDot]; } // Run simulation function runSimulation() { // Cancel any previous animation if (animationId) { cancelAnimationFrame(animationId); } // Reset data simData = []; poincareData = []; // Initial conditions let t = 0; let theta = theta0; let thetaDot = thetaDot0; const dt = 0.05; const simLength = 100; // seconds // Period of driving force const T = 2 * Math.PI / omega; let nextPoincareTime = T; // Generate simulation data while (t < simLength) { // Save current state simData.push({t, theta, thetaDot}); // Check if we should record a Poincar\u00e9 point if (t >= nextPoincareTime) { poincareData.push({t, theta, thetaDot}); nextPoincareTime += T; } // Calculate next state [theta, thetaDot] = rungeKutta4(t, theta, thetaDot, dt); // Normalize theta to be between -\u03c0 and \u03c0 theta = ((theta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; // Increment time t += dt; } // Start visualization drawCharts(); startPendulumAnimation(); } // Draw the time series chart function drawTimeChart() { timeCtx.clearRect(0, 0, timeChart.width, timeChart.height); // Draw axes const padding = 30; const width = timeChart.width; const height = timeChart.height; timeCtx.strokeStyle = '#aaa'; timeCtx.lineWidth = 1; // x-axis timeCtx.beginPath(); timeCtx.moveTo(padding, height/2); timeCtx.lineTo(width - padding, height/2); timeCtx.stroke(); // y-axis timeCtx.beginPath(); timeCtx.moveTo(padding, padding); timeCtx.lineTo(padding, height - padding); timeCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); const maxTime = simData[simData.length - 1].t; // Draw the time series timeCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = padding + (width - 2 * padding) * (simData[i].t / maxTime); const y = height/2 - simData[i].theta * 50; if (i === 0) { timeCtx.moveTo(x, y); } else { timeCtx.lineTo(x, y); } } timeCtx.strokeStyle = '#4c6ef5'; timeCtx.lineWidth = 2; timeCtx.stroke(); } // Draw the phase space chart function drawPhaseChart() { phaseCtx.clearRect(0, 0, phaseChart.width, phaseChart.height); // Draw axes const padding = 30; const width = phaseChart.width; const height = phaseChart.height; phaseCtx.strokeStyle = '#aaa'; phaseCtx.lineWidth = 1; // x-axis phaseCtx.beginPath(); phaseCtx.moveTo(padding, height/2); phaseCtx.lineTo(width - padding, height/2); phaseCtx.stroke(); // y-axis phaseCtx.beginPath(); phaseCtx.moveTo(width/2, padding); phaseCtx.lineTo(width/2, height - padding); phaseCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); // Draw the phase space trajectory phaseCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = width/2 + simData[i].theta * 50; const y = height/2 - simData[i].thetaDot * 30; if (i === 0) { phaseCtx.moveTo(x, y); } else { phaseCtx.lineTo(x, y); } } phaseCtx.strokeStyle = '#e64980'; phaseCtx.lineWidth = 2; phaseCtx.stroke(); } // Draw the Poincar\u00e9 section function drawPoincareChart() { poincareCtx.clearRect(0, 0, poincareChart.width, poincareChart.height); // Draw axes const padding = 30; const width = poincareChart.width; const height = poincareChart.height; poincareCtx.strokeStyle = '#aaa'; poincareCtx.lineWidth = 1; // x-axis poincareCtx.beginPath(); poincareCtx.moveTo(padding, height/2); poincareCtx.lineTo(width - padding, height/2); poincareCtx.stroke(); // y-axis poincareCtx.beginPath(); poincareCtx.moveTo(width/2, padding); poincareCtx.lineTo(width/2, height - padding); poincareCtx.stroke(); // Draw Poincar\u00e9 points for (const point of poincareData) { const x = width/2 + point.theta * 50; const y = height/2 - point.thetaDot * 30; poincareCtx.beginPath(); poincareCtx.arc(x, y, 3, 0, 2*Math.PI); poincareCtx.fillStyle = '#7950f2'; poincareCtx.fill(); } } // Draw all charts function drawCharts() { drawTimeChart(); drawPhaseChart(); drawPoincareChart(); } // Animate the pendulum function startPendulumAnimation() { let frameIndex = 0; const framesPerDataPoint = 2; function drawPendulum() { // Clear canvas pendulumCtx.clearRect(0, 0, pendulumCanvas.width, pendulumCanvas.height); // Get dimensions const width = pendulumCanvas.width; const height = pendulumCanvas.height; const centerX = width / 2; const centerY = height / 3; // Length of pendulum const pendulumLength = height / 2; // Get current state const dataIndex = Math.floor(frameIndex / framesPerDataPoint) % simData.length; const currentTheta = simData[dataIndex].theta; // Calculate pendulum position const bobX = centerX + pendulumLength * Math.sin(currentTheta); const bobY = centerY + pendulumLength * Math.cos(currentTheta); // Draw pivot pendulumCtx.beginPath(); pendulumCtx.arc(centerX, centerY, 5, 0, 2*Math.PI); pendulumCtx.fillStyle = '#333'; pendulumCtx.fill(); // Draw rod pendulumCtx.beginPath(); pendulumCtx.moveTo(centerX, centerY); pendulumCtx.lineTo(bobX, bobY); pendulumCtx.strokeStyle = '#555'; pendulumCtx.lineWidth = 2; pendulumCtx.stroke(); // Draw bob pendulumCtx.beginPath(); pendulumCtx.arc(bobX, bobY, 15, 0, 2*Math.PI); pendulumCtx.fillStyle = '#4c6ef5'; pendulumCtx.fill(); // Increment frame counter frameIndex++; // Request next frame animationId = requestAnimationFrame(drawPendulum); } // Start animation drawPendulum(); } // Run simulation button click handler runBtn.addEventListener('click', runSimulation); // Run the simulation when the page loads window.addEventListener('load', function() { setTimeout(runSimulation, 500); }); 4. Conclusion Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-simulation-example","text":"Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$","title":"2. Simulation Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#trajectory-table","text":"Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74","title":"Trajectory Table"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-optional-interactive-simulation","text":"Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; }","title":"3. Optional: Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-conclusion","text":"Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"4. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Problem 3 - Orbital Period and Orbital Radius Simulation 1. Motivation The relationship between the orbital period and orbital radius, known as Kepler's Third Law , connects planetary motion with gravitational theory. It is expressed as: \\[ T^2 \\propto R^3 \\] Where: - \\(T\\) is the orbital period - \\(R\\) is the orbital radius This simulation explores this relationship in circular orbits using Newtonian gravitation and centripetal force. 2. Theoretical Foundation Using Newton's Law of Gravitation and circular motion: Gravitational Force: $$ F = \\frac{GMm}{R^2} $$ Centripetal Force: $$ F = \\frac{mv^2}{R} $$ Setting the two equal: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity: \\[ v = \\sqrt{\\frac{GM}{R}} \\] Orbital period is: \\[ T = \\frac{2\\pi R}{v} = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] Thus, proving Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM} R^3 \\] 3. Simulation Code Kepler's Third Law body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fa; color: #333; line-height: 1.6; max-width: 1000px; margin: 0 auto; } h1, h2 { color: #2c3e50; text-align: center; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin: 20px 0; } .chart-container { position: relative; height: 400px; margin: 20px 0; } .info { background-color: #f0f4f8; padding: 15px; border-radius: 5px; margin: 20px 0; } .data-table { width: 100%; border-collapse: collapse; margin: 20px 0; } .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: center; } .data-table th { background-color: #f2f2f2; } .data-table tr:nth-child(even) { background-color: #f9f9f9; } .formula { text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; padding: 10px; background-color: #edf2f7; border-radius: 5px; } .footnote { margin-top: 30px; font-size: 0.9em; color: #666; text-align: center; } .planet-orbit { width: 100%; height: 300px; margin: 20px 0; } Kepler's Third Law - Orbital Period vs Radius Kepler's Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit around the Sun. This is expressed as: T\u00b2 \u221d R\u00b3, or more precisely: T = 2\u03c0\u221a(R\u00b3/GM) Where: T is the orbital period R is the semi-major axis of the orbit (or radius for circular orbits) G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) M is the mass of the Sun (1.989 \u00d7 10\u00b3\u2070 kg) Orbital Periods of Inner Planets Planet Orbital Radius (millions km) Orbital Period (days) T\u00b2/R\u00b3 (constant) \u00a9 2025 Astronomical Simulation | Created with HTML, CSS, and JavaScript // Constants const G = 6.67430e-11; // gravitational constant const M = 1.989e30; // mass of the Sun (kg) // Orbital radii in meters const radii = [5.79e10, 1.08e11, 1.50e11, 2.28e11]; const planetLabels = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"]; // Calculate periods using T = 2pi * sqrt(R^3 / GM) const periods = radii.map(r => 2 * Math.PI * Math.sqrt(Math.pow(r, 3) / (G * M))); const periodsDays = periods.map(p => p / (60 * 60 * 24)); // Calculate Kepler constant (T^2/R^3) const keplerConstants = radii.map((r, i) => { const T = periods[i]; return Math.pow(T, 2) / Math.pow(r, 3); }); // Convert radii to millions of km for display const radiiMillionsKm = radii.map(r => (r / 1e9).toFixed(2)); // Populate the data table const tableBody = document.getElementById('planetData'); for (let i = 0; i < planetLabels.length; i++) { const row = document.createElement('tr'); const planetCell = document.createElement('td'); planetCell.textContent = planetLabels[i]; row.appendChild(planetCell); const radiusCell = document.createElement('td'); radiusCell.textContent = radiiMillionsKm[i]; row.appendChild(radiusCell); const periodCell = document.createElement('td'); periodCell.textContent = periodsDays[i].toFixed(2); row.appendChild(periodCell); const constantCell = document.createElement('td'); constantCell.textContent = keplerConstants[i].toExponential(5); row.appendChild(constantCell); tableBody.appendChild(row); } // Create the chart const ctx = document.getElementById('keplerChart').getContext('2d'); const chart = new Chart(ctx, { type: 'scatter', data: { datasets: [{ label: 'Planets', data: radii.map((r, i) => ({ x: r, y: periodsDays[i] })), backgroundColor: 'rgba(75, 192, 192, 0.8)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1, pointRadius: 6, pointHoverRadius: 8 }, { label: 'Kepler\\'s Law Curve', data: generateKeplerCurve(), borderColor: 'rgba(153, 102, 255, 0.7)', backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 2, pointRadius: 0, type: 'line', showLine: true }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Orbital Radius (m)' }, ticks: { callback: function(value) { return (value / 1e10).toFixed(1) + ' \u00d7 10\u00b9\u2070'; } } }, y: { title: { display: true, text: 'Orbital Period (days)' } } }, plugins: { tooltip: { callbacks: { label: function(context) { const index = context.dataIndex; return planetLabels[index] + ' - Radius: ' + radiiMillionsKm[index] + ' million km, Period: ' + periodsDays[index].toFixed(2) + ' days'; } } }, legend: { display: true, position: 'top' } } } }); // Generate points for Kepler's law curve function generateKeplerCurve() { const points = []; const numPoints = 100; const minRadius = 4e10; const maxRadius = 2.5e11; for (let i = 0; i < numPoints; i++) { const r = minRadius + (maxRadius - minRadius) * (i / (numPoints - 1)); const period = 2 * Math.PI * Math.sqrt(Math.pow(r, 3) / (G * M)); const periodDays = period / (60 * 60 * 24); points.push({ x: r, y: periodDays }); } return points; } // Draw the orbit visualization function drawOrbits() { const canvas = document.getElementById('orbitVisualization'); const ctx = canvas.getContext('2d'); // Set canvas dimensions canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; const width = canvas.width; const height = canvas.height; const centerX = width / 2; const centerY = height / 2; // Clear canvas ctx.clearRect(0, 0, width, height); // Define colors for planets const colors = ['#888', '#e6b800', '#3973ac', '#c1440e']; // Scale the orbits to fit the canvas const maxRadius = Math.max(...radii); const scale = (Math.min(width, height) * 0.42) / maxRadius; // Draw Sun ctx.beginPath(); ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI); ctx.fillStyle = '#FDB813'; ctx.fill(); // Draw orbits and planets for (let i = 0; i < radii.length; i++) { const radius = radii[i] * scale; // Draw orbit ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)'; ctx.stroke(); // Calculate planet position (different angle for each planet) const angle = (i * Math.PI / 2) % (2 * Math.PI); const x = centerX + radius * Math.cos(angle); const y = centerY + radius * Math.sin(angle); // Draw planet ctx.beginPath(); ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fillStyle = colors[i]; ctx.fill(); // Add label ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(planetLabels[i], x, y - 12); } } // Run the orbital visualization when the page loads window.addEventListener('load', drawOrbits); window.addEventListener('resize', drawOrbits); 4. Results & Discussion This simulation confirms: The square of the orbital period grows with the cube of the radius. The plotted data aligns with Kepler's Third Law prediction. Real planets like Earth and Mars fit well into the curve. You can extend this model for: - Elliptical orbits - Moons around planets - Exoplanet systems","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-3-orbital-period-and-orbital-radius-simulation","text":"","title":"Problem 3 - Orbital Period and Orbital Radius Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-motivation","text":"The relationship between the orbital period and orbital radius, known as Kepler's Third Law , connects planetary motion with gravitational theory. It is expressed as: \\[ T^2 \\propto R^3 \\] Where: - \\(T\\) is the orbital period - \\(R\\) is the orbital radius This simulation explores this relationship in circular orbits using Newtonian gravitation and centripetal force.","title":"1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-theoretical-foundation","text":"Using Newton's Law of Gravitation and circular motion: Gravitational Force: $$ F = \\frac{GMm}{R^2} $$ Centripetal Force: $$ F = \\frac{mv^2}{R} $$ Setting the two equal: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity: \\[ v = \\sqrt{\\frac{GM}{R}} \\] Orbital period is: \\[ T = \\frac{2\\pi R}{v} = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] Thus, proving Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM} R^3 \\]","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-simulation-code","text":"Kepler's Third Law body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fa; color: #333; line-height: 1.6; max-width: 1000px; margin: 0 auto; } h1, h2 { color: #2c3e50; text-align: center; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin: 20px 0; } .chart-container { position: relative; height: 400px; margin: 20px 0; } .info { background-color: #f0f4f8; padding: 15px; border-radius: 5px; margin: 20px 0; } .data-table { width: 100%; border-collapse: collapse; margin: 20px 0; } .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: center; } .data-table th { background-color: #f2f2f2; } .data-table tr:nth-child(even) { background-color: #f9f9f9; } .formula { text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; padding: 10px; background-color: #edf2f7; border-radius: 5px; } .footnote { margin-top: 30px; font-size: 0.9em; color: #666; text-align: center; } .planet-orbit { width: 100%; height: 300px; margin: 20px 0; }","title":"3. Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-results-discussion","text":"This simulation confirms: The square of the orbital period grows with the cube of the radius. The plotted data aligns with Kepler's Third Law prediction. Real planets like Earth and Mars fit well into the curve. You can extend this model for: - Elliptical orbits - Moons around planets - Exoplanet systems","title":"4. Results &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 - Escape & Cosmic Velocities Simulation 1. Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. 2. Theoretical Foundation The gravitational potential energy and kinetic energy concepts are used to derive these velocities. 1st Cosmic Velocity (Orbital): The minimum speed needed to stay in circular orbit around a planet: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ 2nd Cosmic Velocity (Escape): The minimum speed needed to escape the planet's gravity: $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ 3rd Cosmic Velocity (Solar Escape): The speed needed to escape the entire solar system, relative to the Sun: $$ v_3 = v_2 + v_{\\text{orbital}} $$ Where: - \\(G = 6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body 3. Step-by-Step Derivation We start with energy conservation: - Total mechanical energy at surface = 0 at escape point (infinity) \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for escape velocity: $$ v = \\sqrt{\\frac{2GM}{R}} $$ This equation explains how mass and radius influence the energy needed to escape. 4. Additional Examples and Data Table (Expanded) Celestial Body Mass (kg) Radius (m) v\u2081 (km/s) v\u2082 (km/s) v\u2083 (km/s)* Earth 5.972\u00d710\u00b2\u2074 6.371\u00d710\u2076 7.91 11.19 53.29 Mars 6.417\u00d710\u00b2\u00b3 3.389\u00d710\u2076 3.55 5.03 47.13 Jupiter 1.898\u00d710\u00b2\u2077 6.991\u00d710\u2077 42.57 60.20 102.30 Moon 7.342\u00d710\u00b2\u00b2 1.737\u00d710\u2076 1.68 2.38 44.48 Venus 4.867\u00d710\u00b2\u2074 6.052\u00d710\u2076 7.33 10.36 52.46 Saturn 5.683\u00d710\u00b2\u2076 5.823\u00d710\u2077 25.52 36.09 78.19 * Estimated using Earth's orbital speed around Sun (42.1 km/s) These examples emphasize how mass and radius determine the effort required to escape a celestial body's gravity. 6. Interactive Simulation Code Escape & Cosmic Velocities Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; color: #333; margin: 0; padding: 20px; max-width: 1200px; margin: auto; } h1, h2, h3 { text-align: center; color: #2c3e50; margin-top: 1.5em; } .container { background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 25px 0; } .theory-section { padding: 15px; background-color: #f8f9fa; border-radius: 8px; margin-bottom: 20px; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 15px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .chart-container { width: 100%; max-width: 800px; margin: 0 auto 20px auto; height: 400px; } #simulationArea { width: 100%; background-color: #000; border-radius: 8px; overflow: hidden; position: relative; margin-bottom: 20px; } #spaceCanvas { display: block; background-color: #000; width: 100%; height: 500px; } .control-panel { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; } .control-group { margin-bottom: 10px; min-width: 200px; } label { display: block; margin-bottom: 5px; font-weight: bold; color: #333; } select, input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; font-size: 14px; } .button-group { display: flex; gap: 10px; margin-top: 20px; justify-content: center; } button { padding: 10px 20px; border: none; border-radius: 5px; background-color: #4c6ef5; color: white; font-weight: bold; cursor: pointer; transition: background-color 0.3s; } button:hover { background-color: #364fc7; } button.start { background-color: #40c057; } button.start:hover { background-color: #2f9e44; } button.stop { background-color: #fa5252; } button.stop:hover { background-color: #e03131; } table { width: 100%; border-collapse: collapse; margin: 25px 0; } th, td { border: 1px solid #ddd; padding: 12px; text-align: center; } th { background-color: #f0f4f8; font-weight: bold; } tr:nth-child(even) { background-color: #f9f9f9; } .data-display { margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border-left: 4px solid #4c6ef5; } .note { font-size: 0.9em; color: #666; text-align: center; margin-top: 30px; } Escape & Cosmic Velocities Simulation Theoretical Foundation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Three important velocity thresholds define different space travel capabilities: 1st Cosmic Velocity (Orbital): v\u2081 = \u221a(GM/R) 2nd Cosmic Velocity (Escape): v\u2082 = \u221a2 \u00b7 v\u2081 = \u221a(2GM/R) 3rd Cosmic Velocity (Solar Escape): v\u2083 = v\u2082 + v orbital Where: G = 6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3kg\u207b\u00b9s\u207b\u00b2 M is the mass of the celestial body R is the radius of the celestial body v orbital is the orbital velocity of the planet around the Sun Velocity Comparison Celestial Body 1st Cosmic (km/s) 2nd Cosmic (km/s) 3rd Cosmic (km/s) Interactive Space Travel Simulation Select Celestial Body: Earth Mars Jupiter Moon Venus Saturn Launch Velocity: Custom Velocity 1st Cosmic (Orbital) 2nd Cosmic (Escape) 3rd Cosmic (Solar System Escape) Velocity (km/s): Launch Angle (degrees): Start Simulation Reset Select a celestial body and launch parameters to start the simulation. Mass vs Cosmic Velocities Relationship This graph demonstrates how a celestial body's mass affects its cosmic velocities (with radius held constant). \u00a9 2025 Cosmic Velocities Simulation | Created for GitHub Pages // Constants const G = 6.67430e-11; // Gravitational constant const solarVelocity = 42.1; // Earth's orbital velocity around Sun (km/s) // Celestial bodies data const bodies = [ { name: \"Earth\", mass: 5.972e24, radius: 6371000, color: \"#1e88e5\" }, { name: \"Mars\", mass: 6.417e23, radius: 3389500, color: \"#d32f2f\" }, { name: \"Jupiter\", mass: 1.898e27, radius: 69911000, color: \"#f9a825\" }, { name: \"Moon\", mass: 7.342e22, radius: 1737000, color: \"#9e9e9e\" }, { name: \"Venus\", mass: 4.867e24, radius: 6052000, color: \"#ff9800\" }, { name: \"Saturn\", mass: 5.683e26, radius: 58232000, color: \"#ffeb3b\" } ]; // Calculate cosmic velocities for each body const velocities = bodies.map(body => { const v1 = Math.sqrt(G * body.mass / body.radius) / 1000; // km/s const v2 = Math.sqrt(2) * v1; // km/s const v3 = v2 + solarVelocity; // km/s return { name: body.name, v1, v2, v3, color: body.color }; }); // Populate data table const tableBody = document.getElementById(\"velocityTable\"); velocities.forEach(vel => { const row = document.createElement(\"tr\"); row.innerHTML = ` <td>${vel.name}</td> <td>${vel.v1.toFixed(2)}</td> <td>${vel.v2.toFixed(2)}</td> <td>${vel.v3.toFixed(2)}</td> `; tableBody.appendChild(row); }); // Create velocity comparison chart const ctx = document.getElementById(\"velocityChart\").getContext(\"2d\"); new Chart(ctx, { type: \"bar\", data: { labels: velocities.map(v => v.name), datasets: [ { label: \"1st Cosmic (Orbital)\", data: velocities.map(v => v.v1), backgroundColor: \"#4c6ef5\" }, { label: \"2nd Cosmic (Escape)\", data: velocities.map(v => v.v2), backgroundColor: \"#40c057\" }, { label: \"3rd Cosmic (Solar Escape)\", data: velocities.map(v => v.v3), backgroundColor: \"#fa5252\" } ] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: \"top\" }, title: { display: true, text: \"Cosmic Velocities by Celestial Body\", font: { size: 16 } } }, scales: { y: { title: { display: true, text: \"Velocity (km/s)\", font: { size: 14 } } } } } }); // Create mass vs velocity chart const ctx2 = document.getElementById(\"massVelocityChart\").getContext(\"2d\"); new Chart(ctx2, { type: \"scatter\", data: { datasets: [ { label: \"1st Cosmic Velocity\", data: bodies.map(body => ({ x: body.mass, y: Math.sqrt(G * body.mass / body.radius) / 1000 })), backgroundColor: \"#4c6ef5\", borderColor: \"#4c6ef5\", pointRadius: 6, pointHoverRadius: 8 }, { label: \"2nd Cosmic Velocity\", data: bodies.map(body => ({ x: body.mass, y: Math.sqrt(2 * G * body.mass / body.radius) / 1000 })), backgroundColor: \"#40c057\", borderColor: \"#40c057\", pointRadius: 6, pointHoverRadius: 8 } ] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: \"top\" }, tooltip: { callbacks: { label: function(context) { const index = context.dataIndex; const body = bodies[index]; return `${body.name}: ${context.parsed.y.toFixed(2)} km/s`; } } } }, scales: { x: { title: { display: true, text: \"Body Mass (kg)\", font: { size: 14 } }, type: 'logarithmic', ticks: { callback: function(value) { return `10^${Math.log10(value).toFixed(0)}`; } } }, y: { title: { display: true, text: \"Velocity (km/s)\", font: { size: 14 } } } } } }); // Space Travel Simulation const spaceCanvas = document.getElementById(\"spaceCanvas\"); const ctx3 = spaceCanvas.getContext(\"2d\"); // Set canvas size function resizeCanvas() { spaceCanvas.width = spaceCanvas.clientWidth; spaceCanvas.height = spaceCanvas.clientHeight; } // Initialize canvas resizeCanvas(); window.addEventListener('resize', resizeCanvas); // Simulation variables let selectedBody = bodies[0]; // Default: Earth let animationId = null; let isSimulating = false; let spacecraft = { x: 0, y: 0, vx: 0, vy: 0 }; let trajectory = []; // DOM elements const bodySelect = document.getElementById(\"bodySelect\"); const velocityType = document.getElementById(\"velocityType\"); const customVelocity = document.getElementById(\"customVelocity\"); const launchAngle = document.getElementById(\"launchAngle\"); const startButton = document.getElementById(\"startButton\"); const resetButton = document.getElementById(\"resetButton\"); const flightData = document.getElementById(\"flightData\"); // Event listeners bodySelect.addEventListener(\"change\", updateSelectedBody); velocityType.addEventListener(\"change\", updateVelocityOptions); startButton.addEventListener(\"click\", startSimulation); resetButton.addEventListener(\"click\", resetSimulation); // Update selected body function updateSelectedBody() { const selectedName = bodySelect.value; selectedBody = bodies.find(body => body.name.toLowerCase() === selectedName); updateVelocityOptions(); } // Update velocity options based on selected body function updateVelocityOptions() { const selectedVelType = velocityType.value; const bodyIndex = bodies.findIndex(body => body.name === selectedBody.name); if (selectedVelType === \"first\") { customVelocity.value = velocities[bodyIndex].v1.toFixed(2); customVelocity.disabled = true; } else if (selectedVelType === \"second\") { customVelocity.value = velocities[bodyIndex].v2.toFixed(2); customVelocity.disabled = true; } else if (selectedVelType === \"third\") { customVelocity.value = velocities[bodyIndex].v3.toFixed(2); customVelocity.disabled = true; } else { customVelocity.disabled = false; } } // Start simulation function startSimulation() { if (isSimulating) return; // Get parameters const velocity = parseFloat(customVelocity.value); const angle = parseFloat(launchAngle.value); // Convert angle to radians const angleRad = angle * Math.PI / 180; // Set initial spacecraft position and velocity spacecraft = { x: spaceCanvas.width / 2, y: spaceCanvas.height / 2, vx: velocity * Math.cos(angleRad) * 0.5, vy: -velocity * Math.sin(angleRad) * 0.5 // Negative because canvas y is inverted }; // Clear previous trajectory trajectory = []; trajectory.push({ x: spacecraft.x, y: spacecraft.y }); // Start simulation loop isSimulating = true; if (animationId) cancelAnimationFrame(animationId); simulationLoop(); // Update flight data display updateFlightData(); } // Reset simulation function resetSimulation() { if (animationId) cancelAnimationFrame(animationId); isSimulating = false; trajectory = []; drawScene(); flightData.innerHTML = `<p>Select a celestial body and launch parameters to start the simulation.</p>`; } // Update flight data display function updateFlightData() { const bodyIndex = bodies.findIndex(body => body.name === selectedBody.name); const v1 = velocities[bodyIndex].v1.toFixed(2); const v2 = velocities[bodyIndex].v2.toFixed(2); const velocity = parseFloat(customVelocity.value); const angle = parseFloat(launchAngle.value); let flightResult; if (velocity < parseFloat(v1)) { flightResult = \"Insufficient velocity for orbit. Object will fall back to the surface.\"; } else if (velocity < parseFloat(v2)) { flightResult = \"Sufficient velocity for orbit. Object will enter an elliptical orbit.\"; } else { flightResult = \"Escape velocity achieved. Object will escape the gravitational pull.\"; } flightData.innerHTML = ` <strong>Flight Parameters for ${selectedBody.name}:</strong><br> Launch velocity: ${velocity.toFixed(2)} km/s<br> Launch angle: ${angle}\u00b0<br> Required orbital velocity: ${v1} km/s<br> Required escape velocity: ${v2} km/s<br><br> <strong>Result:</strong> ${flightResult} `; } // Main simulation loop function simulationLoop() { // Update spacecraft position updateSpacecraft(); // Draw scene drawScene(); // Check termination conditions const distanceFromCenter = Math.sqrt( Math.pow(spacecraft.x - spaceCanvas.width/2, 2) + Math.pow(spacecraft.y - spaceCanvas.height/2, 2) ); const bodyRadius = 25; // Visual radius for the planet if (distanceFromCenter < bodyRadius) { // Crashed isSimulating = false; flightData.innerHTML += `<br><strong>Simulation ended:</strong> Spacecraft crashed into ${selectedBody.name}.`; } else if (distanceFromCenter > Math.max(spaceCanvas.width, spaceCanvas.height)) { // Left visible area isSimulating = false; flightData.innerHTML += `<br><strong>Simulation ended:</strong> Spacecraft left visible area.`; } // Continue simulation if still active if (isSimulating) { animationId = requestAnimationFrame(simulationLoop); } } // Update spacecraft position and velocity function updateSpacecraft() { // Scaling factor to make simulation visually interesting const scaleFactor = 0.01; // Calculate direction to body center const dx = spaceCanvas.width/2 - spacecraft.x; const dy = spaceCanvas.height/2 - spacecraft.y; const distance = Math.sqrt(dx*dx + dy*dy); if (distance > 0) { // Calculate gravitational force const forceMagnitude = G * selectedBody.mass / (distance * distance) * scaleFactor; // Apply acceleration due to gravity spacecraft.vx += forceMagnitude * dx / distance; spacecraft.vy += forceMagnitude * dy / distance; } // Update position spacecraft.x += spacecraft.vx; spacecraft.y += spacecraft.vy; // Add to trajectory trajectory.push({ x: spacecraft.x, y: spacecraft.y }); // Limit trajectory length for performance if (trajectory.length > 500) { trajectory.shift(); } } // Draw the scene function drawScene() { // Clear canvas ctx3.clearRect(0, 0, spaceCanvas.width, spaceCanvas.height); // Draw stars in background drawStars(); // Draw celestial body const bodyIndex = bodies.findIndex(body => body.name === selectedBody.name); ctx3.beginPath(); ctx3.arc(spaceCanvas.width/2, spaceCanvas.height/2, 25, 0, Math.PI * 2); ctx3.fillStyle = velocities[bodyIndex].color; ctx3.fill(); // Draw body name ctx3.fillStyle = \"#fff\"; ctx3.font = \"14px Arial\"; ctx3.textAlign = \"center\"; ctx3.fillText(selectedBody.name, spaceCanvas.width/2, spaceCanvas.height/2 - 35); // Draw orbit indicator ctx3.beginPath(); ctx3.arc(spaceCanvas.width/2, spaceCanvas.height/2, 100, 0, Math.PI * 2); ctx3.strokeStyle = \"rgba(255, 255, 255, 0.2)\"; ctx3.stroke(); // Draw escape indicator ctx3.beginPath(); ctx3.arc(spaceCanvas.width/2, spaceCanvas.height/2, 150, 0, Math.PI * 2); ctx3.strokeStyle = \"rgba(255, 255, 255, 0.1)\"; ctx3.stroke(); // Draw trajectory if (trajectory.length > 1) { ctx3.beginPath(); ctx3.moveTo(trajectory[0].x, trajectory[0].y); for (let i = 1; i < trajectory.length; i++) { ctx3.lineTo(trajectory[i].x, trajectory[i].y); } ctx3.strokeStyle = \"#fff\"; ctx3.lineWidth = 1.5; ctx3.stroke(); } // Draw spacecraft if (isSimulating) { ctx3.beginPath(); ctx3.arc(spacecraft.x, spacecraft.y, 4, 0, Math.PI * 2); ctx3.fillStyle = \"#fff\"; ctx3.fill(); } } // Draw stars in background function drawStars() { const numStars = 150; for (let i = 0; i < numStars; i++) { const x = Math.random() * spaceCanvas.width; const y = Math.random() * spaceCanvas.height; const radius = Math.random() * 1.5; const brightness = Math.random() * 0.5 + 0.5; ctx3.beginPath(); ctx3.arc(x, y, radius, 0, Math.PI * 2); ctx3.fillStyle = `rgba(255, 255, 255, ${brightness})`; ctx3.fill(); } } // Initial draw drawScene(); 9. Results & Discussion Jupiter has the highest escape velocities due to its massive size. Earth and Mars require less velocity. The 3rd cosmic velocity includes Sun escape speed, making it the highest. These results are useful in: - Planning satellite orbits - Launching interplanetary missions - Estimating required energy and fuel 10. Applications in Space Exploration 1st velocity: Satellite orbits (e.g., Hubble, ISS) 2nd velocity: Planetary escape (e.g., Apollo missions) 3rd velocity: Deep space exploration (e.g., Voyager probes) This simulation bridges physics with real aerospace design, showing how theoretical formulas apply to modern technology. 11. Conclusion This enhanced visualization and expanded data illustrate how escape and orbital velocities vary across celestial bodies. It highlights the necessity for precise calculation and engineering in space science.","title":"Problem 2 - Escape &amp; Cosmic Velocities Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-cosmic-velocities-simulation","text":"","title":"Problem 2 - Escape &amp; Cosmic Velocities Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-theoretical-foundation","text":"The gravitational potential energy and kinetic energy concepts are used to derive these velocities. 1st Cosmic Velocity (Orbital): The minimum speed needed to stay in circular orbit around a planet: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ 2nd Cosmic Velocity (Escape): The minimum speed needed to escape the planet's gravity: $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ 3rd Cosmic Velocity (Solar Escape): The speed needed to escape the entire solar system, relative to the Sun: $$ v_3 = v_2 + v_{\\text{orbital}} $$ Where: - \\(G = 6.67430 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius of the celestial body","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-step-by-step-derivation","text":"We start with energy conservation: - Total mechanical energy at surface = 0 at escape point (infinity) \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for escape velocity: $$ v = \\sqrt{\\frac{2GM}{R}} $$ This equation explains how mass and radius influence the energy needed to escape.","title":"3. Step-by-Step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-additional-examples-and-data-table-expanded","text":"Celestial Body Mass (kg) Radius (m) v\u2081 (km/s) v\u2082 (km/s) v\u2083 (km/s)* Earth 5.972\u00d710\u00b2\u2074 6.371\u00d710\u2076 7.91 11.19 53.29 Mars 6.417\u00d710\u00b2\u00b3 3.389\u00d710\u2076 3.55 5.03 47.13 Jupiter 1.898\u00d710\u00b2\u2077 6.991\u00d710\u2077 42.57 60.20 102.30 Moon 7.342\u00d710\u00b2\u00b2 1.737\u00d710\u2076 1.68 2.38 44.48 Venus 4.867\u00d710\u00b2\u2074 6.052\u00d710\u2076 7.33 10.36 52.46 Saturn 5.683\u00d710\u00b2\u2076 5.823\u00d710\u2077 25.52 36.09 78.19 * Estimated using Earth's orbital speed around Sun (42.1 km/s) These examples emphasize how mass and radius determine the effort required to escape a celestial body's gravity.","title":"4. Additional Examples and Data Table (Expanded)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-interactive-simulation-code","text":"Escape & Cosmic Velocities Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; color: #333; margin: 0; padding: 20px; max-width: 1200px; margin: auto; } h1, h2, h3 { text-align: center; color: #2c3e50; margin-top: 1.5em; } .container { background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 25px 0; } .theory-section { padding: 15px; background-color: #f8f9fa; border-radius: 8px; margin-bottom: 20px; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 15px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .chart-container { width: 100%; max-width: 800px; margin: 0 auto 20px auto; height: 400px; } #simulationArea { width: 100%; background-color: #000; border-radius: 8px; overflow: hidden; position: relative; margin-bottom: 20px; } #spaceCanvas { display: block; background-color: #000; width: 100%; height: 500px; } .control-panel { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; } .control-group { margin-bottom: 10px; min-width: 200px; } label { display: block; margin-bottom: 5px; font-weight: bold; color: #333; } select, input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; font-size: 14px; } .button-group { display: flex; gap: 10px; margin-top: 20px; justify-content: center; } button { padding: 10px 20px; border: none; border-radius: 5px; background-color: #4c6ef5; color: white; font-weight: bold; cursor: pointer; transition: background-color 0.3s; } button:hover { background-color: #364fc7; } button.start { background-color: #40c057; } button.start:hover { background-color: #2f9e44; } button.stop { background-color: #fa5252; } button.stop:hover { background-color: #e03131; } table { width: 100%; border-collapse: collapse; margin: 25px 0; } th, td { border: 1px solid #ddd; padding: 12px; text-align: center; } th { background-color: #f0f4f8; font-weight: bold; } tr:nth-child(even) { background-color: #f9f9f9; } .data-display { margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px; border-left: 4px solid #4c6ef5; } .note { font-size: 0.9em; color: #666; text-align: center; margin-top: 30px; }","title":"6. Interactive Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#9-results-discussion","text":"Jupiter has the highest escape velocities due to its massive size. Earth and Mars require less velocity. The 3rd cosmic velocity includes Sun escape speed, making it the highest. These results are useful in: - Planning satellite orbits - Launching interplanetary missions - Estimating required energy and fuel","title":"9. Results &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#10-applications-in-space-exploration","text":"1st velocity: Satellite orbits (e.g., Hubble, ISS) 2nd velocity: Planetary escape (e.g., Apollo missions) 3rd velocity: Deep space exploration (e.g., Voyager probes) This simulation bridges physics with real aerospace design, showing how theoretical formulas apply to modern technology.","title":"10. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-conclusion","text":"This enhanced visualization and expanded data illustrate how escape and orbital velocities vary across celestial bodies. It highlights the necessity for precise calculation and engineering in space science.","title":"11. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 - Trajectories of a Freely Released Payload Near Earth 1. Theoretical Background We use Newton's law of gravity: \\[ F = \\frac{GMm}{r^2} \\] \\( G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \\( M \\) : mass of Earth \\( m \\) : mass of payload \\( r \\) : distance from Earth's center The escape velocity formula: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{R}} \\] If: \\( v < v_{\\text{escape}} \\) \u2192 elliptical or reentry \\( v = v_{\\text{escape}} \\) \u2192 parabolic trajectory \\( v > v_{\\text{escape}} \\) \u2192 hyperbolic escape 2. Interactive Simulation Test different initial velocities and angles to explore: - Orbital insertion - Escape - Reentry Payload Trajectory Simulations body { font-family: Arial, sans-serif; background: #f4f7fa; color: #333; padding: 20px; } h1, h2 { text-align: center; color: #2c3e50; } canvas { display: block; margin: 20px auto; border: 1px solid #ccc; background: #000; } .section { margin-bottom: 60px; } Trajectories of a Freely Released Payload 1\ufe0f. Payload Trajectory near Earth (Interactive) Initial Velocity (m/s): Launch Angle (\u00b0): Simulate 2. Trajectory Comparison Based On Initial Velocity 3. Payload Trajectories by Velocity Type // First Simulation const G = 6.6743e-11; const M = 5.972e24; const R = 6371000; const ctx1 = document.getElementById(\"simCanvas\").getContext(\"2d\"); function start() { let v = parseFloat(document.getElementById(\"speed\").value); let angle = parseFloat(document.getElementById(\"angle\").value) * Math.PI / 180; let x = 0; let y = R + 500000; let vx = v * Math.cos(angle); let vy = -v * Math.sin(angle); let path = []; let dt = 0.1; function update() { let r = Math.sqrt(x*x + y*y); let a = G * M / (r * r); let ax = -a * x / r; let ay = -a * y / r; vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; path.push([x, y]); ctx1.clearRect(0, 0, 600, 600); ctx1.fillStyle = \"#2c3e50\"; ctx1.beginPath(); ctx1.arc(300, 300, 50, 0, 2 * Math.PI); ctx1.fill(); ctx1.beginPath(); ctx1.strokeStyle = \"#fff\"; for (let i = 0; i < path.length; i++) { let px = 300 + path[i][0] / 200000; let py = 300 - path[i][1] / 200000; if (i === 0) ctx1.moveTo(px, py); else ctx1.lineTo(px, py); } ctx1.stroke(); ctx1.fillStyle = \"#f59f00\"; ctx1.beginPath(); ctx1.arc(300 + x/200000, 300 - y/200000, 4, 0, 2*Math.PI); ctx1.fill(); if (path.length < 800) requestAnimationFrame(update); } update(); } // Second Simulation - Trajectory Comparison const ctx2 = document.getElementById(\"comparisonChart\").getContext(\"2d\"); new Chart(ctx2, { type: 'line', data: { labels: ['0 km', '2000 km', '4000 km', '6000 km', '8000 km'], datasets: [ { label: 'Elliptical (7.5 km/s)', data: [0, 250, 400, 450, 300], borderColor: '#4c6ef5', fill: false }, { label: 'Parabolic (11.2 km/s)', data: [0, 500, 1000, 1500, 2000], borderColor: '#82c91e', fill: false }, { label: 'Hyperbolic (14.0 km/s)', data: [0, 800, 1600, 3000, 5000], borderColor: '#f59f00', fill: false } ] }, options: { responsive: true, plugins: { title: { display: true, text: 'Trajectory Comparison Based on Initial Velocity' } }, scales: { y: { title: { display: true, text: 'Altitude (km)' } }, x: { title: { display: true, text: 'Horizontal Distance' } } } } }); // Third Simulation - Payload Velocities const ctx3 = document.getElementById(\"velocityTypeChart\").getContext(\"2d\"); new Chart(ctx3, { type: 'bar', data: { labels: ['Elliptical', 'Parabolic', 'Hyperbolic'], datasets: [{ label: 'Velocity (km/s)', data: [7.5, 11.2, 14.0], backgroundColor: ['#4c6ef5', '#82c91e', '#f59f00'] }] }, options: { plugins: { title: { display: true, text: 'Payload Trajectories by Velocity Type' } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (km/s)' } } } } }); 3. Real World Examples Scenario Trajectory Mission Example Satellite Deployment Elliptical Orbit Starlink, ISS Moon Travel Parabolic Arc Apollo Missions Interplanetary Probe Hyperbolic Path Voyager 1, Voyager 2 4. How It Works (Numerical Model) We simulate motion using a basic Euler Integration scheme: Position update \\[ \\vec{r}_{\\text{new}} = \\vec{r}_{\\text{old}} + \\vec{v} \\cdot \\Delta t \\] Velocity update \\[ \\vec{v}_{\\text{new}} = \\vec{v}_{\\text{old}} + \\vec{a} \\cdot \\Delta t \\] Acceleration from gravity \\[ \\vec{a} = -\\frac{GM}{r^2} \\cdot \\hat{r} \\] 5. Conclusion This project helps you visualize how gravitational physics works in real missions, and how trajectory decisions affect the fate of a payload. It combines physics , programming , and space engineering in a powerful, visual way.","title":"Problem 3 - Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3 - Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-background","text":"We use Newton's law of gravity: \\[ F = \\frac{GMm}{r^2} \\] \\( G = 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \\( M \\) : mass of Earth \\( m \\) : mass of payload \\( r \\) : distance from Earth's center The escape velocity formula: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{R}} \\] If: \\( v < v_{\\text{escape}} \\) \u2192 elliptical or reentry \\( v = v_{\\text{escape}} \\) \u2192 parabolic trajectory \\( v > v_{\\text{escape}} \\) \u2192 hyperbolic escape","title":"1. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-interactive-simulation","text":"Test different initial velocities and angles to explore: - Orbital insertion - Escape - Reentry Payload Trajectory Simulations body { font-family: Arial, sans-serif; background: #f4f7fa; color: #333; padding: 20px; } h1, h2 { text-align: center; color: #2c3e50; } canvas { display: block; margin: 20px auto; border: 1px solid #ccc; background: #000; } .section { margin-bottom: 60px; }","title":"2. Interactive Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-real-world-examples","text":"Scenario Trajectory Mission Example Satellite Deployment Elliptical Orbit Starlink, ISS Moon Travel Parabolic Arc Apollo Missions Interplanetary Probe Hyperbolic Path Voyager 1, Voyager 2","title":"3. Real World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-how-it-works-numerical-model","text":"We simulate motion using a basic Euler Integration scheme: Position update \\[ \\vec{r}_{\\text{new}} = \\vec{r}_{\\text{old}} + \\vec{v} \\cdot \\Delta t \\] Velocity update \\[ \\vec{v}_{\\text{new}} = \\vec{v}_{\\text{old}} + \\vec{a} \\cdot \\Delta t \\] Acceleration from gravity \\[ \\vec{a} = -\\frac{GM}{r^2} \\cdot \\hat{r} \\]","title":"4. How It Works (Numerical Model)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"This project helps you visualize how gravitational physics works in real missions, and how trajectory decisions affect the fate of a payload. It combines physics , programming , and space engineering in a powerful, visual way.","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Waves Interference Patterns on a Water Surface Problem Statement The aim of this study is to analyze interference patterns created by circular waves emitted from point sources located at the vertices of a regular polygon. The waves interfere constructively and destructively, leading to visually observable patterns. Theoretical Foundation The displacement of a circular wave on the water surface, emanating from a point source located at \\( (x_0, y_0) \\) , is described by the Single Disturbance Equation : \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\( \\eta(x, y, t) \\) : Displacement at point \\( (x, y) \\) and time \\( t \\) - \\( A \\) : Amplitude of the wave - \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number - \\( \\omega = 2\\pi f \\) : Angular frequency - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to the point \\( (x, y) \\) - \\( \\phi \\) : Initial phase Superposition Principle The total displacement on the water surface due to multiple sources is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of wave sources (vertices of the polygon). Simulation Method 1. Real-Valued Model (Cosine-Based Approach) The real-valued model computes the sum of cosine wave disturbances from each source. The amplitude at each point decays with distance. 2. Complex Exponential Model (Phasor Approach) The complex model uses phasor representation, summing complex wave contributions from each source and then taking the real part: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} e^{j(kr_i - \\omega t + \\phi_i)} \\] \\[ \\eta_{\\text{total}}(x, y, t) = \\Re \\left\\{ \\sum_{i=1}^{N} \\eta_i(x, y, t) \\right\\} \\] Wave Interference Simulation and Visualization body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; margin: 0 auto; padding: 20px; color: #333; line-height: 1.6; max-width: 1000px; } h1 { color: #2c3e50; text-align: center; margin-bottom: 20px; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px; } .controls { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 20px; } .control-group { display: flex; flex-direction: column; min-width: 200px; } label { margin-bottom: 5px; font-weight: bold; } input, select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; width: 100%; font-size: 14px; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 5px; } button:hover { background-color: #364fc7; } .canvas-container { display: flex; justify-content: center; margin: 20px 0; } canvas { border: 1px solid #ddd; border-radius: 4px; background-color: #000; } .color-scale { display: flex; align-items: center; justify-content: center; margin: 20px 0; } .color-bar { width: 300px; height: 20px; background: linear-gradient(to right, blue, white, red); border-radius: 2px; margin: 0 10px; } .scale-label { font-size: 14px; color: #666; } #plot3d { width: 100%; height: 800px; margin-top: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; } Wave Interference Simulation and Visualization Amplitude (A): 1.0 Wavelength (\u03bb): 2.0 Number of Sources: 3 (Triangle) 4 (Square) 5 (Pentagon) 6 (Hexagon) 8 (Octagon) Source Radius: 3.0 Update Simulation Update 3D Plot Negative Positive const canvas = document.getElementById('interferenceCanvas'); const ctx = canvas.getContext('2d'); const amplitudeInput = document.getElementById('amplitude'); const wavelengthInput = document.getElementById('wavelength'); const sourcesInput = document.getElementById('sources'); const radiusInput = document.getElementById('radius'); const updateBtn = document.getElementById('updateBtn'); const updatePlotBtn = document.getElementById('updatePlotBtn'); const ampValue = document.getElementById('ampValue'); const waveValue = document.getElementById('waveValue'); const radiusValue = document.getElementById('radiusValue'); let A = parseFloat(amplitudeInput.value); let wavelength = parseFloat(wavelengthInput.value); let numSources = parseInt(sourcesInput.value); let sourceRadius = parseFloat(radiusInput.value); let frequency = 1.0; let k = 2 * Math.PI / wavelength; let omega = 2 * Math.PI * frequency; let phi = 0; let t = 0; let animationId; ampValue.textContent = A.toFixed(1); waveValue.textContent = wavelength.toFixed(1); radiusValue.textContent = sourceRadius.toFixed(1); amplitudeInput.addEventListener('input', () => { A = parseFloat(amplitudeInput.value); ampValue.textContent = A.toFixed(1); }); wavelengthInput.addEventListener('input', () => { wavelength = parseFloat(wavelengthInput.value); k = 2 * Math.PI / wavelength; waveValue.textContent = wavelength.toFixed(1); }); radiusInput.addEventListener('input', () => { sourceRadius = parseFloat(radiusInput.value); radiusValue.textContent = sourceRadius.toFixed(1); }); updateBtn.addEventListener('click', () => { cancelAnimationFrame(animationId); t = 0; runAnimation(); }); updatePlotBtn.addEventListener('click', () => { plotSurface(); }); function regularPolygon(n, radius) { const points = []; for (let i = 0; i < n; i++) { const angle = (2 * Math.PI * i) / n; points.push([radius * Math.cos(angle), radius * Math.sin(angle)]); } return points; } function mapToColor(value, min, max) { const normalized = (value - min) / (max - min); let r, g, b; if (normalized < 0.5) { const t = normalized * 2; r = 255 * t; g = 255 * t; b = 255; } else { const t = (normalized - 0.5) * 2; r = 255; g = 255 * (1 - t); b = 255 * (1 - t); } return [r, g, b]; } function runAnimation() { numSources = parseInt(sourcesInput.value); k = 2 * Math.PI / wavelength; const width = canvas.width; const height = canvas.height; const imageData = ctx.createImageData(width, height); const data = imageData.data; const scale = 20; const offsetX = width / 2; const offsetY = height / 2; const sources = regularPolygon(numSources, sourceRadius); const waveValues = new Array(width * height); let minVal = Infinity; let maxVal = -Infinity; for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const physX = (x - offsetX) / scale; const physY = (y - offsetY) / scale; let eta = 0; for (const [x0, y0] of sources) { const R = Math.sqrt((physX - x0) ** 2 + (physY - y0) ** 2); const amplitude = R < 0.01 ? A : A / Math.sqrt(R + 0.01); eta += amplitude * Math.cos(k * R - omega * t + phi); } const index = y * width + x; waveValues[index] = eta; minVal = Math.min(minVal, eta); maxVal = Math.max(maxVal, eta); } } for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const index = y * width + x; const eta = waveValues[index]; const [r, g, b] = mapToColor(eta, minVal, maxVal); const pixelIndex = (y * width + x) * 4; data[pixelIndex] = r; data[pixelIndex + 1] = g; data[pixelIndex + 2] = b; data[pixelIndex + 3] = 255; } } ctx.putImageData(imageData, 0, 0); drawSources(sources, scale, offsetX, offsetY); t += 0.05; animationId = requestAnimationFrame(runAnimation); } function drawSources(sources, scale, offsetX, offsetY) { ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; for (const [x0, y0] of sources) { const canvasX = x0 * scale + offsetX; const canvasY = y0 * scale + offsetY; ctx.beginPath(); ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); } } function plotSurface() { const A = parseFloat(amplitudeInput.value); const wavelength = parseFloat(wavelengthInput.value); const numSources = parseInt(sourcesInput.value); const sourceRadius = parseFloat(radiusInput.value); const k = 2 * Math.PI / wavelength; const omega = 2 * Math.PI * 1.0; // fixed frequency const phi = 0; const t = 0; // snapshot at t = 0 const size = 50; const range = 5; const x = [...Array(size)].map((_, i) => -range + (2 * range * i) / (size - 1)); const y = x; const X = [], Y = [], Z = []; const sources = regularPolygon(numSources, sourceRadius); for (let i = 0; i < size; i++) { X[i] = []; Y[i] = []; Z[i] = []; for (let j = 0; j < size; j++) { const xi = x[j]; const yi = y[i]; let eta = 0; for (const [x0, y0] of sources) { const R = Math.sqrt((xi - x0) ** 2 + (yi - y0) ** 2); const amplitude = R < 0.01 ? A : A / Math.sqrt(R + 0.01); eta += amplitude * Math.cos(k * R - omega * t + phi); } X[i][j] = xi; Y[i][j] = yi; Z[i][j] = eta; } } const data = [{ type: 'surface', x: X, y: Y, z: Z, colorscale: 'Jet', contours: { z: { show: true, usecolormap: true, highlightcolor: \"#42f462\", project: { z: true } } } }]; const layout = { title: '3D Wave Interference Pattern', autosize: true, scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Displacement \u03b7(x, y, t)' } } }; Plotly.newPlot('plot3d', data, layout); } runAnimation(); plotSurface(); Visualization and Analysis Constructive Interference: Occurs when wave crests meet, amplifying the displacement. Destructive Interference: Occurs when crests and troughs meet, canceling each other out. The interactive simulation allows the adjustment of: - Amplitude - Wavelength - Number of sources (polygon selection) - Source radius Both real and complex models are visualized on separate canvases for comparison. Conclusions This project demonstrates how the superposition of wave disturbances can lead to complex interference patterns. The approach provides insights into wave behavior and phase interactions using both real and complex wave models.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves","text":"","title":"Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"The aim of this study is to analyze interference patterns created by circular waves emitted from point sources located at the vertices of a regular polygon. The waves interfere constructively and destructively, leading to visually observable patterns.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-foundation","text":"The displacement of a circular wave on the water surface, emanating from a point source located at \\( (x_0, y_0) \\) , is described by the Single Disturbance Equation : \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\( \\eta(x, y, t) \\) : Displacement at point \\( (x, y) \\) and time \\( t \\) - \\( A \\) : Amplitude of the wave - \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number - \\( \\omega = 2\\pi f \\) : Angular frequency - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to the point \\( (x, y) \\) - \\( \\phi \\) : Initial phase","title":"Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"The total displacement on the water surface due to multiple sources is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of wave sources (vertices of the polygon).","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-method","text":"","title":"Simulation Method"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-real-valued-model-cosine-based-approach","text":"The real-valued model computes the sum of cosine wave disturbances from each source. The amplitude at each point decays with distance.","title":"1. Real-Valued Model (Cosine-Based Approach)"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-complex-exponential-model-phasor-approach","text":"The complex model uses phasor representation, summing complex wave contributions from each source and then taking the real part: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} e^{j(kr_i - \\omega t + \\phi_i)} \\] \\[ \\eta_{\\text{total}}(x, y, t) = \\Re \\left\\{ \\sum_{i=1}^{N} \\eta_i(x, y, t) \\right\\} \\] Wave Interference Simulation and Visualization body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f7fa; margin: 0 auto; padding: 20px; color: #333; line-height: 1.6; max-width: 1000px; } h1 { color: #2c3e50; text-align: center; margin-bottom: 20px; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px; } .controls { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-bottom: 20px; } .control-group { display: flex; flex-direction: column; min-width: 200px; } label { margin-bottom: 5px; font-weight: bold; } input, select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; width: 100%; font-size: 14px; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 5px; } button:hover { background-color: #364fc7; } .canvas-container { display: flex; justify-content: center; margin: 20px 0; } canvas { border: 1px solid #ddd; border-radius: 4px; background-color: #000; } .color-scale { display: flex; align-items: center; justify-content: center; margin: 20px 0; } .color-bar { width: 300px; height: 20px; background: linear-gradient(to right, blue, white, red); border-radius: 2px; margin: 0 10px; } .scale-label { font-size: 14px; color: #666; } #plot3d { width: 100%; height: 800px; margin-top: 20px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; }","title":"2. Complex Exponential Model (Phasor Approach)"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-and-analysis","text":"Constructive Interference: Occurs when wave crests meet, amplifying the displacement. Destructive Interference: Occurs when crests and troughs meet, canceling each other out. The interactive simulation allows the adjustment of: - Amplitude - Wavelength - Number of sources (polygon selection) - Source radius Both real and complex models are visualized on separate canvases for comparison.","title":"Visualization and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusions","text":"This project demonstrates how the superposition of wave disturbances can lead to complex interference patterns. The approach provides insights into wave behavior and phase interactions using both real and complex wave models.","title":"Conclusions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Overview The Lorentz force describes the force acting on charged particles moving through electric and magnetic fields, defined by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where: - \\(q\\) is the particle's charge, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the velocity of the particle, - \\(\\mathbf{B}\\) is the magnetic field. Simulation Setup We will use Python with NumPy and Matplotlib to simulate and visualize particle trajectories under different configurations: Uniform Magnetic Field Combined Electric and Magnetic Fields Crossed Electric and Magnetic Fields Simulation Lorentz Force Simulation canvas { border: 1px solid #ccc; } const canvas = document.getElementById('simulationCanvas'); const ctx = canvas.getContext('2d'); // Constants const q = 1.6e-19; // Coulombs const m = 9.1e-31; // kg const dt = 1e-11; // s const steps = 10000; // Initial conditions let r = {x: 400, y: 300}; let v = {x: 1e6, y: 0}; // Fields const E = {x: 0, y: 0}; const B = 0.1; // Tesla, perpendicular to plane function lorentzForce(v, E, B, q) { return { x: q * (E.x + v.y * B), y: q * (E.y - v.x * B) }; } function runSimulation() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(r.x, r.y); for (let i = 0; i < steps; i++) { const a = lorentzForce(v, E, B, q); v.x += (a.x / m) * dt; v.y += (a.y / m) * dt; r.x += v.x * dt * 1e-5; // scaled for visualization r.y += v.y * dt * 1e-5; ctx.lineTo(r.x, r.y); } ctx.strokeStyle = '#007BFF'; ctx.stroke(); } runSimulation(); Practical Application Discussion Simulations of the Lorentz force provide insights into several key technologies and scientific applications: Cyclotrons and Particle Accelerators: Charged particles moving in magnetic fields follow circular or helical trajectories. This principle underpins the design and operation of cyclotrons, enabling controlled particle acceleration. Mass Spectrometry: Utilizes magnetic fields to separate ions based on mass-to-charge ratios, essential for analytical chemistry and biology. Magnetic Traps and Plasma Confinement: Controlling particle motion with electromagnetic fields is fundamental in fusion reactors, such as tokamaks. Extensions for Complex Scenarios Future enhancements could include: Non-uniform magnetic fields to simulate realistic scenarios found in astrophysics and advanced plasma research. Implementing relativistic corrections for high-energy particle simulations. Introducing stochastic elements or collisions to better mimic conditions found in real plasmas. This foundational simulation allows us to build towards more intricate and realistic models, providing deeper understanding and predictive capabilities in electromagnetism and particle physics.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#overview","text":"The Lorentz force describes the force acting on charged particles moving through electric and magnetic fields, defined by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where: - \\(q\\) is the particle's charge, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{v}\\) is the velocity of the particle, - \\(\\mathbf{B}\\) is the magnetic field.","title":"Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-setup","text":"We will use Python with NumPy and Matplotlib to simulate and visualize particle trajectories under different configurations: Uniform Magnetic Field Combined Electric and Magnetic Fields Crossed Electric and Magnetic Fields","title":"Simulation Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation","text":"Lorentz Force Simulation canvas { border: 1px solid #ccc; } const canvas = document.getElementById('simulationCanvas'); const ctx = canvas.getContext('2d'); // Constants const q = 1.6e-19; // Coulombs const m = 9.1e-31; // kg const dt = 1e-11; // s const steps = 10000; // Initial conditions let r = {x: 400, y: 300}; let v = {x: 1e6, y: 0}; // Fields const E = {x: 0, y: 0}; const B = 0.1; // Tesla, perpendicular to plane function lorentzForce(v, E, B, q) { return { x: q * (E.x + v.y * B), y: q * (E.y - v.x * B) }; } function runSimulation() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(r.x, r.y); for (let i = 0; i < steps; i++) { const a = lorentzForce(v, E, B, q); v.x += (a.x / m) * dt; v.y += (a.y / m) * dt; r.x += v.x * dt * 1e-5; // scaled for visualization r.y += v.y * dt * 1e-5; ctx.lineTo(r.x, r.y); } ctx.strokeStyle = '#007BFF'; ctx.stroke(); } runSimulation();","title":"Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-application-discussion","text":"Simulations of the Lorentz force provide insights into several key technologies and scientific applications: Cyclotrons and Particle Accelerators: Charged particles moving in magnetic fields follow circular or helical trajectories. This principle underpins the design and operation of cyclotrons, enabling controlled particle acceleration. Mass Spectrometry: Utilizes magnetic fields to separate ions based on mass-to-charge ratios, essential for analytical chemistry and biology. Magnetic Traps and Plasma Confinement: Controlling particle motion with electromagnetic fields is fundamental in fusion reactors, such as tokamaks.","title":"Practical Application Discussion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions-for-complex-scenarios","text":"Future enhancements could include: Non-uniform magnetic fields to simulate realistic scenarios found in astrophysics and advanced plasma research. Implementing relativistic corrections for high-energy particle simulations. Introducing stochastic elements or collisions to better mimic conditions found in real plasmas. This foundational simulation allows us to build towards more intricate and realistic models, providing deeper understanding and predictive capabilities in electromagnetism and particle physics.","title":"Extensions for Complex Scenarios"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Lorentz Force Simulation in Electromagnetic Fields Project Goal This project aims to simulate and visualize the behavior of charged particles under the influence of electric \\( \\vec{E} \\) and magnetic \\( \\vec{B} \\) fields, using the Lorentz force law: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] We'll explore real-world applications such as cyclotrons, magnetic traps, and plasma confinement devices by modeling particle trajectories using numerical techniques. Theoretical Foundation The Lorentz force determines how charged particles move through electromagnetic fields. Its effects depend on: - The magnitude and direction of the electric field \\( \\vec{E} \\) - The direction and strength of the magnetic field \\( \\vec{B} \\) - The particle's velocity \\( \\vec{v} \\) , charge \\( q \\) , and mass \\( m \\) Key motion behaviors: - Circular or helical motion in uniform \\( \\vec{B} \\) fields - Drift motion in crossed \\( \\vec{E} \\) and \\( \\vec{B} \\) fields Task Breakdown Exploration of Applications Identify real-world systems using Lorentz force: Particle accelerators (cyclotrons, synchrotrons) Plasma confinement (tokamaks) Mass spectrometers Discuss how \\( \\vec{E} \\) and \\( \\vec{B} \\) fields influence motion Simulating Particle Motion Compute and visualize trajectories under: A uniform magnetic field Combined uniform electric and magnetic fields Crossed \\( \\vec{E} \\) and \\( \\vec{B} \\) fields Simulate circular, helical, and drift motion Parameter Exploration Allow variation of: Field strengths ( \\( \\vec{E}, \\vec{B} \\) ) Initial velocity \\( \\vec{v} \\) Particle properties ( \\( q, m \\) ) Observe how parameters affect motion Visualization Create clear 2D plots of particle trajectories Highlight Larmor radius and \\( \\vec{E} \\times \\vec{B} \\) drift Interactive Simulation Lorentz Force Simulation canvas { border: 1px solid #ccc; } const canvas = document.getElementById('simulationCanvas'); const ctx = canvas.getContext('2d'); // Constants const q = 1.6e-19; // Coulombs const m = 9.1e-31; // kg const dt = 1e-11; // s const steps = 10000; // Initial conditions let r = {x: 400, y: 300}; let v = {x: 1e6, y: 0}; // Fields const E = {x: 0, y: 0}; const B = 0.1; // Tesla, perpendicular to plane function lorentzForce(v, E, B, q) { return { x: q * (E.x + v.y * B), y: q * (E.y - v.x * B) }; } function runSimulation() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(r.x, r.y); for (let i = 0; i < steps; i++) { const a = lorentzForce(v, E, B, q); v.x += (a.x / m) * dt; v.y += (a.y / m) * dt; r.x += v.x * dt * 1e-5; // scaled for visualization r.y += v.y * dt * 1e-5; ctx.lineTo(r.x, r.y); } ctx.strokeStyle = '#007BFF'; ctx.stroke(); } runSimulation(); Observations & Analysis In uniform \\( \\vec{B} \\) : Circular motion (Larmor orbits) In \\( \\vec{E} \\times \\vec{B} \\) fields: Particle drifts Increasing \\( v \\) or \\( B \\) : Tighter orbits Example: Larmor Radius \\[ r_L = \\frac{mv_\\perp}{qB} \\] Suggestions for Extension Non-uniform magnetic fields (simulate magnetic mirrors) Vary electric field strength for E-field acceleration Relativistic effects ( \\( \\gamma = \\frac{1}{\\sqrt{1 - v^2/c^2}} \\) ) Interactive sliders for real-time parameter tuning","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#lorentz-force-simulation-in-electromagnetic-fields","text":"","title":"Lorentz Force Simulation in Electromagnetic Fields"},{"location":"1%20Physics/6%20Statistics/Problem_1/#project-goal","text":"This project aims to simulate and visualize the behavior of charged particles under the influence of electric \\( \\vec{E} \\) and magnetic \\( \\vec{B} \\) fields, using the Lorentz force law: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] We'll explore real-world applications such as cyclotrons, magnetic traps, and plasma confinement devices by modeling particle trajectories using numerical techniques.","title":"Project Goal"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theoretical-foundation","text":"The Lorentz force determines how charged particles move through electromagnetic fields. Its effects depend on: - The magnitude and direction of the electric field \\( \\vec{E} \\) - The direction and strength of the magnetic field \\( \\vec{B} \\) - The particle's velocity \\( \\vec{v} \\) , charge \\( q \\) , and mass \\( m \\) Key motion behaviors: - Circular or helical motion in uniform \\( \\vec{B} \\) fields - Drift motion in crossed \\( \\vec{E} \\) and \\( \\vec{B} \\) fields","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-breakdown","text":"","title":"Task Breakdown"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploration-of-applications","text":"Identify real-world systems using Lorentz force: Particle accelerators (cyclotrons, synchrotrons) Plasma confinement (tokamaks) Mass spectrometers Discuss how \\( \\vec{E} \\) and \\( \\vec{B} \\) fields influence motion","title":"Exploration of Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulating-particle-motion","text":"Compute and visualize trajectories under: A uniform magnetic field Combined uniform electric and magnetic fields Crossed \\( \\vec{E} \\) and \\( \\vec{B} \\) fields Simulate circular, helical, and drift motion","title":"Simulating Particle Motion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration","text":"Allow variation of: Field strengths ( \\( \\vec{E}, \\vec{B} \\) ) Initial velocity \\( \\vec{v} \\) Particle properties ( \\( q, m \\) ) Observe how parameters affect motion","title":"Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization","text":"Create clear 2D plots of particle trajectories Highlight Larmor radius and \\( \\vec{E} \\times \\vec{B} \\) drift","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interactive-simulation","text":"Lorentz Force Simulation canvas { border: 1px solid #ccc; } const canvas = document.getElementById('simulationCanvas'); const ctx = canvas.getContext('2d'); // Constants const q = 1.6e-19; // Coulombs const m = 9.1e-31; // kg const dt = 1e-11; // s const steps = 10000; // Initial conditions let r = {x: 400, y: 300}; let v = {x: 1e6, y: 0}; // Fields const E = {x: 0, y: 0}; const B = 0.1; // Tesla, perpendicular to plane function lorentzForce(v, E, B, q) { return { x: q * (E.x + v.y * B), y: q * (E.y - v.x * B) }; } function runSimulation() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(r.x, r.y); for (let i = 0; i < steps; i++) { const a = lorentzForce(v, E, B, q); v.x += (a.x / m) * dt; v.y += (a.y / m) * dt; r.x += v.x * dt * 1e-5; // scaled for visualization r.y += v.y * dt * 1e-5; ctx.lineTo(r.x, r.y); } ctx.strokeStyle = '#007BFF'; ctx.stroke(); } runSimulation();","title":"Interactive Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-analysis","text":"In uniform \\( \\vec{B} \\) : Circular motion (Larmor orbits) In \\( \\vec{E} \\times \\vec{B} \\) fields: Particle drifts Increasing \\( v \\) or \\( B \\) : Tighter orbits","title":"Observations &amp; Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-larmor-radius","text":"\\[ r_L = \\frac{mv_\\perp}{qB} \\]","title":"Example: Larmor Radius"},{"location":"1%20Physics/6%20Statistics/Problem_1/#suggestions-for-extension","text":"Non-uniform magnetic fields (simulate magnetic mirrors) Vary electric field strength for E-field acceleration Relativistic effects ( \\( \\gamma = \\frac{1}{\\sqrt{1 - v^2/c^2}} \\) ) Interactive sliders for real-time parameter tuning","title":"Suggestions for Extension"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}