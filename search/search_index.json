{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis 1. Theoretical Foundation Deriving Equations of Motion Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\] Family of Solutions Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges. 2. Analysis of the Range The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Factors Affecting Range Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) . 3. Practical Applications Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity. 4. Implementation Simulation Simulation Parameters Initial Velocity (m/s): 20 Launch Angle (degrees): 45 Gravity (m/s\u00b2): 9.81 Initial Height (m): 0 Air Resistance Coefficient: 0 Run Simulation 0.00 Range (m) 0.00 Max Height (m) 0.00 Flight Time (s) Trajectory Visualization Range vs. Launch Angle Analysis Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0. // Get DOM elements const initialVelocitySlider = document.getElementById('initial-velocity'); const launchAngleSlider = document.getElementById('launch-angle'); const gravitySlider = document.getElementById('gravity'); const initialHeightSlider = document.getElementById('initial-height'); const airResistanceSlider = document.getElementById('air-resistance'); const velocityValue = document.getElementById('velocity-value'); const angleValue = document.getElementById('angle-value'); const gravityValue = document.getElementById('gravity-value'); const heightValue = document.getElementById('height-value'); const resistanceValue = document.getElementById('resistance-value'); const rangeValue = document.getElementById('range-value'); const maxHeightValue = document.getElementById('max-height-value'); const timeValue = document.getElementById('time-value'); const simulateBtn = document.getElementById('simulate-btn'); const trajectoryCanvas = document.getElementById('trajectory-canvas'); const rangeAngleCanvas = document.getElementById('range-angle-canvas'); const optimalAngleInfo = document.getElementById('optimal-angle-info'); // Canvas setup const trajCtx = trajectoryCanvas.getContext('2d'); const rangeCtx = rangeAngleCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { trajectoryCanvas.width = trajectoryCanvas.clientWidth; trajectoryCanvas.height = trajectoryCanvas.clientHeight; rangeAngleCanvas.width = rangeAngleCanvas.clientWidth; rangeAngleCanvas.height = rangeAngleCanvas.clientHeight; } window.addEventListener('resize', resizeCanvas); resizeCanvas(); // Display slider values initialVelocitySlider.addEventListener('input', () => { velocityValue.textContent = initialVelocitySlider.value; }); launchAngleSlider.addEventListener('input', () => { angleValue.textContent = launchAngleSlider.value; }); gravitySlider.addEventListener('input', () => { gravityValue.textContent = parseFloat(gravitySlider.value).toFixed(2); }); initialHeightSlider.addEventListener('input', () => { heightValue.textContent = initialHeightSlider.value; }); airResistanceSlider.addEventListener('input', () => { resistanceValue.textContent = parseFloat(airResistanceSlider.value).toFixed(2); }); // Simulation calculations function calculateTrajectory(v0, angle, gravity, height, airResistance) { // Convert angle to radians const angleRad = angle * Math.PI / 180; // Initial velocities const vx0 = v0 * Math.cos(angleRad); const vy0 = v0 * Math.sin(angleRad); let flightTime; let x = []; let y = []; // Calculate flight time (analytical solution without air resistance) if (airResistance === 0) { flightTime = (vy0 + Math.sqrt(vy0 * vy0 + 2 * gravity * height)) / gravity; // Handle very small angles with initial height if (angle < 0.1 && height > 0) { flightTime = (2 * vy0) / gravity + Math.sqrt(2 * height / gravity); } // Time steps for trajectory const timeSteps = 1000; const dt = flightTime / timeSteps; // Analytical calculation for (let i = 0; i <= timeSteps; i++) { const t = i * dt; x.push(vx0 * t); y.push(height + vy0 * t - 0.5 * gravity * t * t); // Stop if we hit the ground if (y[i] < 0) { y[i] = 0; x = x.slice(0, i + 1); y = y.slice(0, i + 1); break; } } } else { // Numerical calculation with air resistance const dt = 0.01; let t = 0; let yPos = height; let xPos = 0; let vx = vx0; let vy = vy0; while (yPos >= 0) { // Update velocities vx = vx - airResistance * vx * dt; vy = vy - gravity * dt - airResistance * vy * dt; // Update position xPos = xPos + vx * dt; yPos = yPos + vy * dt; x.push(xPos); y.push(yPos); t += dt; // Avoid infinite loops or extremely long calculations if (t > 100 || xPos > 10000) break; } flightTime = t; // Fix the last point if (y[y.length - 1] < 0) { y[y.length - 1] = 0; } } // Calculate range const horizontalRange = x[x.length - 1]; // Calculate maximum height let maxHeight = height; for (let i = 0; i < y.length; i++) { if (y[i] > maxHeight) { maxHeight = y[i]; } } return { x: x, y: y, range: horizontalRange, maxHeight: maxHeight, flightTime: flightTime }; } // Generate range vs angle chart function generateRangeVsAngleChart(v0, gravity, height) { const angles = []; const ranges = []; // Calculate range for each angle for (let angle = 0; angle <= 90; angle += 1) { angles.push(angle); const traj = calculateTrajectory(v0, angle, gravity, height, 0); ranges.push(traj.range); } // Find maximum range let maxRange = 0; let maxAngle = 0; for (let i = 0; i < ranges.length; i++) { if (ranges[i] > maxRange) { maxRange = ranges[i]; maxAngle = angles[i]; } } return { angles: angles, ranges: ranges, maxRange: maxRange, maxAngle: maxAngle }; } // Draw trajectory graph function drawTrajectory(data) { const canvas = trajectoryCanvas; const ctx = trajCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xMax = Math.max(...data.x) * 1.1; const yMax = Math.max(data.maxHeight * 1.2, 10); const xScale = plotWidth / xMax; const yScale = plotHeight / yMax; // Ground line ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Horizontal Distance (m)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Height (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= xMax; x += xMax / 5) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(Math.round(x).toString(), xPos, canvas.height - marginY + 15); } // Y axis values for (let y = 0; y <= yMax; y += yMax / 5) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw trajectory ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; for (let i = 0; i < data.x.length; i++) { const xPos = marginX + data.x[i] * xScale; const yPos = canvas.height - marginY - data.y[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Starting point ctx.beginPath(); ctx.fillStyle = '#e74c3c'; ctx.arc(marginX, canvas.height - marginY - data.y[0] * yScale, 5, 0, 2 * Math.PI); ctx.fill(); // Highest point const maxHeightIndex = data.y.indexOf(data.maxHeight); const maxHeightX = data.x[maxHeightIndex]; ctx.beginPath(); ctx.fillStyle = '#27ae60'; ctx.arc( marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Landing point ctx.beginPath(); ctx.fillStyle = '#9b59b6'; ctx.arc( marginX + data.x[data.x.length - 1] * xScale, canvas.height - marginY - data.y[data.y.length - 1] * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Labels ctx.font = '12px Arial'; ctx.fillStyle = '#333'; // Start label ctx.textAlign = 'left'; ctx.fillText('Start', marginX + 10, canvas.height - marginY - data.y[0] * yScale - 10); // Peak label ctx.textAlign = 'center'; ctx.fillText( `Peak: ${data.maxHeight.toFixed(2)}m`, marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale - 10 ); // Range label ctx.textAlign = 'right'; ctx.fillText( `Range: ${data.range.toFixed(2)}m`, marginX + data.x[data.x.length - 1] * xScale - 10, canvas.height - marginY - data.y[data.y.length - 1] * yScale - 10 ); } // Draw range vs angle chart function drawRangeVsAngleChart(data) { const canvas = rangeAngleCanvas; const ctx = rangeCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xScale = plotWidth / 90; const yScale = plotHeight / (data.maxRange * 1.1); // X axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Launch Angle (degrees)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Range (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= 90; x += 15) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(x.toString(), xPos, canvas.height - marginY + 15); } // Y axis values const yStep = data.maxRange / 5; for (let y = 0; y <= data.maxRange; y += yStep) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw chart ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; for (let i = 0; i < data.angles.length; i++) { const xPos = marginX + data.angles[i] * xScale; const yPos = canvas.height - marginY - data.ranges[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Mark maximum point const maxXPos = marginX + data.maxAngle * xScale; const maxYPos = canvas.height - marginY - data.maxRange * yScale; ctx.beginPath(); ctx.fillStyle = '#2980b9'; ctx.arc(maxXPos, maxYPos, 5, 0, 2 * Math.PI); ctx.fill(); // Maximum label ctx.font = '12px Arial'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.fillText( `Max Range: ${data.maxRange.toFixed(2)}m at ${data.maxAngle.toFixed(1)}\u00b0`, maxXPos, maxYPos - 10 ); } // Run simulation function runSimulation() { // Get parameters const v0 = parseFloat(initialVelocitySlider.value); const angle = parseFloat(launchAngleSlider.value); const gravity = parseFloat(gravitySlider.value); const height = parseFloat(initialHeightSlider.value); const airResistance = parseFloat(airResistanceSlider.value); // Calculate trajectory const trajData = calculateTrajectory(v0, angle, gravity, height, airResistance); // Update metrics rangeValue.textContent = trajData.range.toFixed(2); maxHeightValue.textContent = trajData.maxHeight.toFixed(2); timeValue.textContent = trajData.flightTime.toFixed(2); // Draw trajectory graph drawTrajectory(trajData); // Calculate and draw range vs angle chart const rangeAngleData = generateRangeVsAngleChart(v0, gravity, height); drawRangeVsAngleChart(rangeAngleData); // Update optimal angle info if (height === 0 && airResistance === 0) { optimalAngleInfo.textContent = \"Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0.\"; } else if (height > 0 && airResistance === 0) { optimalAngleInfo.textContent = \"With initial height, the optimal launch angle for maximum range is slightly less than 45\u00b0.\"; } else if (airResistance > 0) { optimalAngleInfo.textContent = \"With air resistance, the optimal launch angle is typically less than 45\u00b0 and depends on the projectile's properties.\"; } } // Simulate button click event simulateBtn.addEventListener('click', runSimulation); // Run initial simulation when page loads window.addEventListener('load', runSimulation);","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-equations-of-motion","text":"Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Deriving Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\]","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#factors-affecting-range","text":"Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) .","title":"Factors Affecting Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation","text":"","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Projectile Motion Analysis 1. Theoretical Foundation Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 2. Simulation Example Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$ Trajectory Table Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74 3. Optional: Interactive Simulation # Problem 2 Forced Damped Pendulum body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 1rem; text-align: center; } canvas { background: white; border: 1px solid #ccc; } h1 { margin-bottom: 1rem; } Forced Damped Pendulum const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); let gamma = 0.5, A = 1.2, omega = 0.67, omega0 = 1.0; let theta = 0.2, thetaDot = 0.0, t = 0, dt = 0.05; let points = []; function rk4(t, y, dt) { const f = (t, y) => { const [theta, thetaDot] = y; const dtheta = thetaDot; const dthetaDot = -gamma * thetaDot - omega0**2 * Math.sin(theta) + A * Math.cos(omega * t); return [dtheta, dthetaDot]; }; const k1 = f(t, y); const k2 = f(t + dt/2, y.map((v,i) => v + dt*k1[i]/2)); const k3 = f(t + dt/2, y.map((v,i) => v + dt*k2[i]/2)); const k4 = f(t + dt, y.map((v,i) => v + dt*k3[i])); return y.map((v,i) => v + dt/6*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i])); } function step() { [theta, thetaDot] = rk4(t, [theta, thetaDot], dt); t += dt; points.push([t, theta]); if (points.length > canvas.width) points.shift(); } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); points.forEach(([_, y], i) => { const x = i; const yCoord = canvas.height / 2 - y * 100; if (i === 0) ctx.moveTo(x, yCoord); else ctx.lineTo(x, yCoord); }); ctx.strokeStyle = \"blue\"; ctx.stroke(); } function loop() { step(); draw(); requestAnimationFrame(loop); } loop(); 4. Conclusion Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-simulation-example","text":"Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$","title":"2. Simulation Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#trajectory-table","text":"Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74","title":"Trajectory Table"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-optional-interactive-simulation","text":"# Problem 2 Forced Damped Pendulum body { font-family: Arial, sans-serif; background: #f4f4f4; margin: 0; padding: 1rem; text-align: center; } canvas { background: white; border: 1px solid #ccc; } h1 { margin-bottom: 1rem; }","title":"3. Optional: Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-conclusion","text":"Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"4. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_3/","text":"Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; } canvas { display: block; width: 100%; height: 100%; background-color: #f8f9fa; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color: #364fc7; } #phase-space, #time-series { width: 100%; height: 300px; margin-bottom: 20px; background-color: white; border: 1px solid #e1e4e8; border-radius: 4px; } #poincare { width: 100%; height: 300px; background-color: white; border: 1px solid #e1e4e8; border-radius: 4px; } .chart-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-top: 20px; width: 100%; } .charts-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; } Forced Damped Pendulum Simulation and Analysis Simulation Parameters Damping Coefficient (\u03b3) 0.50 Driving Amplitude (A) 1.20 Driving Frequency (\u03c9) 0.67 Natural Frequency (\u03c9\u2080) 1.00 Initial Angle (\u03b8\u2080) 0.20 Initial Angular Velocity (\u03b8\u0307\u2080) 0.00 Run Simulation Pendulum Visualization Equation of Motion: d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) This simulation demonstrates the behavior of a forced damped pendulum. Adjust the parameters to observe how the pendulum responds under different conditions, from periodic motion to chaotic behavior. Pendulum Dynamics Analysis Angular Displacement vs Time Shows how the pendulum angle changes over time, revealing periodic or chaotic patterns. Phase Space Plots angular velocity against angle, showing the system's overall dynamic behavior. Poincar\u00e9 Section Samples the phase space at regular intervals synchronized with the driving force, revealing long-term behavior patterns and potential chaos. \u00a9 2025 Physics Simulation Project | Created with HTML, CSS, and JavaScript // Pendulum physics parameters let gamma = 0.5; // damping coefficient let A = 1.2; // driving amplitude let omega = 0.67; // driving frequency let omega0 = 1.0; // natural frequency let theta0 = 0.2; // initial angle let thetaDot0 = 0.0; // initial angular velocity // Simulation variables let t = 0; let theta = theta0; let thetaDot = thetaDot0; let dt = 0.05; let simulationData = []; let poincareData = []; const maxDataPoints = 2000; // Get DOM elements const pendulumCanvas = document.getElementById('pendulum-canvas'); const simulateBtn = document.getElementById('simulate-btn'); const timeSeriesCanvas = document.getElementById('time-series'); const phaseSpaceCanvas = document.getElementById('phase-space'); const poincareCanvas = document.getElementById('poincare'); // Setup context for drawing const pendulumCtx = pendulumCanvas.getContext('2d'); const timeSeriesCtx = timeSeriesCanvas.getContext('2d'); const phaseSpaceCtx = phaseSpaceCanvas.getContext('2d'); const poincareCtx = poincareCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { const devicePixelRatio = window.devicePixelRatio || 1; // Pendulum canvas pendulumCanvas.width = pendulumCanvas.clientWidth * devicePixelRatio; pendulumCanvas.height = pendulumCanvas.clientHeight * devicePixelRatio; pendulumCtx.scale(devicePixelRatio, devicePixelRatio); // Time series canvas timeSeriesCanvas.width = timeSeriesCanvas.clientWidth * devicePixelRatio; timeSeriesCanvas.height = timeSeriesCanvas.clientHeight * devicePixelRatio; timeSeriesCtx.scale(devicePixelRatio, devicePixelRatio); // Phase space canvas phaseSpaceCanvas.width = phaseSpaceCanvas.clientWidth * devicePixelRatio; phaseSpaceCanvas.height = phaseSpaceCanvas.clientHeight * devicePixelRatio; phaseSpaceCtx.scale(devicePixelRatio, devicePixelRatio); // Poincare canvas poincareCanvas.width = poincareCanvas.clientWidth * devicePixelRatio; poincareCanvas.height = poincareCanvas.clientHeight * devicePixelRatio; poincareCtx.scale(devicePixelRatio, devicePixelRatio); } // Initialize canvases resizeCanvas(); window.addEventListener('resize', resizeCanvas); // Update slider value displays function updateSliderDisplay(id, value) { document.getElementById(`${id}-value`).textContent = value.toFixed(2); } // Set up slider events document.getElementById('gamma').addEventListener('input', function() { gamma = parseFloat(this.value); updateSliderDisplay('gamma', gamma); }); document.getElementById('amplitude').addEventListener('input', function() { A = parseFloat(this.value); updateSliderDisplay('amplitude', A); }); document.getElementById('omega').addEventListener('input', function() { omega = parseFloat(this.value); updateSliderDisplay('omega', omega); }); document.getElementById('omega0').addEventListener('input', function() { omega0 = parseFloat(this.value); updateSliderDisplay('omega0', omega0); }); document.getElementById('theta0').addEventListener('input', function() { theta0 = parseFloat(this.value); updateSliderDisplay('theta0', theta0); }); document.getElementById('thetaDot0').addEventListener('input', function() { thetaDot0 = parseFloat(this.value); updateSliderDisplay('thetaDot0', thetaDot0); }); // Pendulum ODE function function pendulumODE(t, y) { const [theta, thetaDot] = y; // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) const thetaDotDot = -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); return [thetaDot, thetaDotDot]; } // RK4 step function function rk4Step(t, y, dt) { const k1 = pendulumODE(t, y); const y2 = [ y[0] + k1[0] * dt / 2, y[1] + k1[1] * dt / 2 ]; const k2 = pendulumODE(t + dt / 2, y2); const y3 = [ y[0] + k2[0] * dt / 2, y[1] + k2[1] * dt / 2 ]; const k3 = pendulumODE(t + dt / 2, y3); const y4 = [ y[0] + k3[0] * dt, y[1] + k3[1] * dt ]; const k4 = pendulumODE(t + dt, y4); return [ y[0] + (dt / 6) * (k1[0] + 2 * k2[0] + 2 * k3[0] + k4[0]), y[1] + (dt / 6) * (k1[1] + 2 * k2[1] + 2 * k3[1] + k4[1]) ]; } // Run simulation function runSimulation() { // Reset simulation t = 0; theta = theta0; thetaDot = thetaDot0; simulationData = []; poincareData = []; // The driving period const T = 2 * Math.PI / omega; let nextPoincareTime = T; // Add initial point simulationData.push({ t, theta, thetaDot }); // Run simulation for a fixed number of steps for (let i = 0; i < maxDataPoints; i++) { // Calculate next state using RK4 [theta, thetaDot] = rk4Step(t, [theta, thetaDot], dt); // Update time t += dt; // Normalize theta to [-\u03c0, \u03c0] theta = ((theta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; // Add point to trajectory simulationData.push({ t, theta, thetaDot }); // Check if we should add a point to the Poincar\u00e9 section if (t >= nextPoincareTime) { poincareData.push({ t, theta, thetaDot }); nextPoincareTime += T; } } // Draw all visualizations drawPendulum(); drawTimeSeries(); drawPhaseSpace(); drawPoincare(); } // Draw pendulum animation function drawPendulum() { if (simulationData.length === 0) return; const width = pendulumCanvas.width / window.devicePixelRatio; const height = pendulumCanvas.height / window.devicePixelRatio; const centerX = width / 2; const centerY = height / 3; const length = height / 2; pendulumCtx.clearRect(0, 0, width, height); // Draw pivot pendulumCtx.beginPath(); pendulumCtx.arc(centerX, centerY, 5, 0, Math.PI * 2); pendulumCtx.fillStyle = '#333'; pendulumCtx.fill(); // Get current state (last data point) const { theta } = simulationData[simulationData.length - 1]; // Calculate pendulum position const bobX = centerX + length * Math.sin(theta); const bobY = centerY + length * Math.cos(theta); // Draw rod pendulumCtx.beginPath(); pendulumCtx.moveTo(centerX, centerY); pendulumCtx.lineTo(bobX, bobY); pendulumCtx.strokeStyle = '#555'; pendulumCtx.lineWidth = 2; pendulumCtx.stroke(); // Draw bob pendulumCtx.beginPath(); pendulumCtx.arc(bobX, bobY, 15, 0, Math.PI * 2); pendulumCtx.fillStyle = '#4c6ef5'; pendulumCtx.fill(); // Draw trace pendulumCtx.beginPath(); // Only show the last 100 points for the trace const startIdx = Math.max(0, simulationData.length - 100); for (let i = startIdx; i < simulationData.length; i++) { const { theta } = simulationData[i]; const x = centerX + length * Math.sin(theta); const y = centerY + length * Math.cos(theta); if (i === startIdx) { pendulumCtx.moveTo(x, y); } else { pendulumCtx.lineTo(x, y); } } pendulumCtx.strokeStyle = 'rgba(76, 110, 245, 0.3)'; pendulumCtx.lineWidth = 2; pendulumCtx.stroke(); // Continue animation requestAnimationFrame(drawPendulum); } // Draw time series chart function drawTimeSeries() { if (simulationData.length === 0) return; const width = timeSeriesCanvas.width / window.devicePixelRatio; const height = timeSeriesCanvas.height / window.devicePixelRatio; const padding = 30; timeSeriesCtx.clearRect(0, 0, width, height); // Draw axes timeSeriesCtx.beginPath(); timeSeriesCtx.moveTo(padding, height - padding); timeSeriesCtx.lineTo(width - padding, height - padding); timeSeriesCtx.moveTo(padding, padding); timeSeriesCtx.lineTo(padding, height - padding); timeSeriesCtx.strokeStyle = '#aaa'; timeSeriesCtx.lineWidth = 1; timeSeriesCtx.stroke(); // Label axes timeSeriesCtx.fillStyle = '#555'; timeSeriesCtx.textAlign = 'center'; timeSeriesCtx.fillText('Time (s)', width / 2, height - 10); timeSeriesCtx.save(); timeSeriesCtx.translate(15, height / 2); timeSeriesCtx.rotate(-Math.PI / 2); timeSeriesCtx.fillText('Angle (rad)', 0, 0); timeSeriesCtx.restore(); // Draw time series timeSeriesCtx.beginPath(); // Sample data to avoid too many points const stride = Math.max(1, Math.floor(simulationData.length / 300)); let maxTime = simulationData[simulationData.length - 1].t; for (let i = 0; i < simulationData.length; i += stride) { const { t, theta } = simulationData[i]; const x = padding + (width - 2 * padding) * (t / maxTime); const y = (height - 2 * padding) / 2 - theta * (height - 2 * padding) / 6 + padding; if (i === 0) { timeSeriesCtx.moveTo(x, y); } else { timeSeriesCtx.lineTo(x, y); } } timeSeriesCtx.strokeStyle = '#4c6ef5'; timeSeriesCtx.lineWidth = 2; timeSeriesCtx.stroke(); } // Draw phase space chart function drawPhaseSpace() { if (simulationData.length === 0) return; const width = phaseSpaceCanvas.width / window.devicePixelRatio; const height = phaseSpaceCanvas.height / window.devicePixelRatio; const padding = 30; phaseSpaceCtx.clearRect(0, 0, width, height); // Draw axes phaseSpaceCtx.beginPath(); phaseSpaceCtx.moveTo(padding, height / 2); phaseSpaceCtx.lineTo(width - padding, height / 2); phaseSpaceCtx.moveTo(width / 2, padding); phaseSpaceCtx.lineTo(width / 2, height - padding); phaseSpaceCtx.strokeStyle = '#aaa'; phaseSpaceCtx.lineWidth = 1; phaseSpaceCtx.stroke(); // Label axes phaseSpaceCtx.fillStyle = '#555'; phaseSpaceCtx.textAlign = 'center'; phaseSpaceCtx.fillText('Angle (rad)', width / 2, height - 10); phaseSpaceCtx.save(); phaseSpaceCtx.translate(15, height / 2); phaseSpaceCtx.rotate(-Math.PI / 2); phaseSpaceCtx.fillText('Angular Velocity (rad/s)', 0, 0); phaseSpaceCtx.restore(); // Draw phase space phaseSpaceCtx.beginPath(); // Sample data to avoid too many points const stride = Math.max(1, Math.floor(simulationData.length / 300)); for (let i = 0; i < simulationData.length; i += stride) { const { theta, thetaDot } = simulationData[i]; const x = width / 2 + theta * (width - 2 * padding) / 6; const y = height / 2 - thetaDot * (height - 2 * padding) / 6; if (i === 0) { phaseSpaceCtx.moveTo(x, y); } else { phaseSpaceCtx.lineTo(x, y); } } phaseSpaceCtx.strokeStyle = '#f06595'; phaseSpaceCtx.lineWidth = 1.5; phaseSpaceCtx.stroke(); } // Draw Poincare section function drawPoincare() { if (poincareData.length === 0) return; const width = poincareCanvas.width / window.devicePixelRatio; const height = poincareCanvas.height / window.devicePixelRatio; const padding = 30; poincareCtx.clearRect(0, 0, width, height); // Draw axes poincareCtx.beginPath(); poincareCtx.moveTo(padding, height / 2); poincareCtx.lineTo(width - padding, height / 2); poincareCtx.moveTo(width / 2, padding); poincareCtx.lineTo(width / 2, height - padding); poincareCtx.strokeStyle = '#aaa'; poincareCtx.lineWidth = 1; poincareCtx.stroke(); // Label axes poincareCtx.fillStyle = '#555'; poincareCtx.textAlign = 'center'; poincareCtx.fillText('Angle (rad)', width / 2, height - 10); poincareCtx.save(); poincareCtx.translate(15, height / 2); poincareCtx.rotate(-Math.PI / 2); poincareCtx.fillText('Angular Velocity (rad/s)', 0, 0); poincareCtx.restore(); // Draw Poincare points for (let i = 0; i < poincareData.length; i++) { const { theta, thetaDot } = poincareData[i]; const x = width / 2 + theta * (width - 2 * padding) / 6; const y = height / 2 - thetaDot * (height - 2 * padding) / 6; poincareCtx.beginPath(); poincareCtx.arc(x, y, 2, 0, Math.PI * 2); poincareCtx.fillStyle = '#7950f2'; poincareCtx.fill(); } } // Set up simulation button simulateBtn.addEventListener('click', runSimulation); // Initialize the simulation on load window.addEventListener('load', runSimulation);","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}