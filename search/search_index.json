{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis 1. Theoretical Foundation Deriving Equations of Motion Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\] Family of Solutions Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges. 2. Analysis of the Range The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Factors Affecting Range Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) . 3. Practical Applications Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity. 4. Implementation Simulation Simulation Parameters Initial Velocity (m/s): 20 Launch Angle (degrees): 45 Gravity (m/s\u00b2): 9.81 Initial Height (m): 0 Air Resistance Coefficient: 0 Run Simulation 0.00 Range (m) 0.00 Max Height (m) 0.00 Flight Time (s) Trajectory Visualization Range vs. Launch Angle Analysis Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0. // Get DOM elements const initialVelocitySlider = document.getElementById('initial-velocity'); const launchAngleSlider = document.getElementById('launch-angle'); const gravitySlider = document.getElementById('gravity'); const initialHeightSlider = document.getElementById('initial-height'); const airResistanceSlider = document.getElementById('air-resistance'); const velocityValue = document.getElementById('velocity-value'); const angleValue = document.getElementById('angle-value'); const gravityValue = document.getElementById('gravity-value'); const heightValue = document.getElementById('height-value'); const resistanceValue = document.getElementById('resistance-value'); const rangeValue = document.getElementById('range-value'); const maxHeightValue = document.getElementById('max-height-value'); const timeValue = document.getElementById('time-value'); const simulateBtn = document.getElementById('simulate-btn'); const trajectoryCanvas = document.getElementById('trajectory-canvas'); const rangeAngleCanvas = document.getElementById('range-angle-canvas'); const optimalAngleInfo = document.getElementById('optimal-angle-info'); // Canvas setup const trajCtx = trajectoryCanvas.getContext('2d'); const rangeCtx = rangeAngleCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { trajectoryCanvas.width = trajectoryCanvas.clientWidth; trajectoryCanvas.height = trajectoryCanvas.clientHeight; rangeAngleCanvas.width = rangeAngleCanvas.clientWidth; rangeAngleCanvas.height = rangeAngleCanvas.clientHeight; } window.addEventListener('resize', resizeCanvas); resizeCanvas(); // Display slider values initialVelocitySlider.addEventListener('input', () => { velocityValue.textContent = initialVelocitySlider.value; }); launchAngleSlider.addEventListener('input', () => { angleValue.textContent = launchAngleSlider.value; }); gravitySlider.addEventListener('input', () => { gravityValue.textContent = parseFloat(gravitySlider.value).toFixed(2); }); initialHeightSlider.addEventListener('input', () => { heightValue.textContent = initialHeightSlider.value; }); airResistanceSlider.addEventListener('input', () => { resistanceValue.textContent = parseFloat(airResistanceSlider.value).toFixed(2); }); // Simulation calculations function calculateTrajectory(v0, angle, gravity, height, airResistance) { // Convert angle to radians const angleRad = angle * Math.PI / 180; // Initial velocities const vx0 = v0 * Math.cos(angleRad); const vy0 = v0 * Math.sin(angleRad); let flightTime; let x = []; let y = []; // Calculate flight time (analytical solution without air resistance) if (airResistance === 0) { flightTime = (vy0 + Math.sqrt(vy0 * vy0 + 2 * gravity * height)) / gravity; // Handle very small angles with initial height if (angle < 0.1 && height > 0) { flightTime = (2 * vy0) / gravity + Math.sqrt(2 * height / gravity); } // Time steps for trajectory const timeSteps = 1000; const dt = flightTime / timeSteps; // Analytical calculation for (let i = 0; i <= timeSteps; i++) { const t = i * dt; x.push(vx0 * t); y.push(height + vy0 * t - 0.5 * gravity * t * t); // Stop if we hit the ground if (y[i] < 0) { y[i] = 0; x = x.slice(0, i + 1); y = y.slice(0, i + 1); break; } } } else { // Numerical calculation with air resistance const dt = 0.01; let t = 0; let yPos = height; let xPos = 0; let vx = vx0; let vy = vy0; while (yPos >= 0) { // Update velocities vx = vx - airResistance * vx * dt; vy = vy - gravity * dt - airResistance * vy * dt; // Update position xPos = xPos + vx * dt; yPos = yPos + vy * dt; x.push(xPos); y.push(yPos); t += dt; // Avoid infinite loops or extremely long calculations if (t > 100 || xPos > 10000) break; } flightTime = t; // Fix the last point if (y[y.length - 1] < 0) { y[y.length - 1] = 0; } } // Calculate range const horizontalRange = x[x.length - 1]; // Calculate maximum height let maxHeight = height; for (let i = 0; i < y.length; i++) { if (y[i] > maxHeight) { maxHeight = y[i]; } } return { x: x, y: y, range: horizontalRange, maxHeight: maxHeight, flightTime: flightTime }; } // Generate range vs angle chart function generateRangeVsAngleChart(v0, gravity, height) { const angles = []; const ranges = []; // Calculate range for each angle for (let angle = 0; angle <= 90; angle += 1) { angles.push(angle); const traj = calculateTrajectory(v0, angle, gravity, height, 0); ranges.push(traj.range); } // Find maximum range let maxRange = 0; let maxAngle = 0; for (let i = 0; i < ranges.length; i++) { if (ranges[i] > maxRange) { maxRange = ranges[i]; maxAngle = angles[i]; } } return { angles: angles, ranges: ranges, maxRange: maxRange, maxAngle: maxAngle }; } // Draw trajectory graph function drawTrajectory(data) { const canvas = trajectoryCanvas; const ctx = trajCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xMax = Math.max(...data.x) * 1.1; const yMax = Math.max(data.maxHeight * 1.2, 10); const xScale = plotWidth / xMax; const yScale = plotHeight / yMax; // Ground line ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Horizontal Distance (m)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Height (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= xMax; x += xMax / 5) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(Math.round(x).toString(), xPos, canvas.height - marginY + 15); } // Y axis values for (let y = 0; y <= yMax; y += yMax / 5) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw trajectory ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; for (let i = 0; i < data.x.length; i++) { const xPos = marginX + data.x[i] * xScale; const yPos = canvas.height - marginY - data.y[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Starting point ctx.beginPath(); ctx.fillStyle = '#e74c3c'; ctx.arc(marginX, canvas.height - marginY - data.y[0] * yScale, 5, 0, 2 * Math.PI); ctx.fill(); // Highest point const maxHeightIndex = data.y.indexOf(data.maxHeight); const maxHeightX = data.x[maxHeightIndex]; ctx.beginPath(); ctx.fillStyle = '#27ae60'; ctx.arc( marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Landing point ctx.beginPath(); ctx.fillStyle = '#9b59b6'; ctx.arc( marginX + data.x[data.x.length - 1] * xScale, canvas.height - marginY - data.y[data.y.length - 1] * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Labels ctx.font = '12px Arial'; ctx.fillStyle = '#333'; // Start label ctx.textAlign = 'left'; ctx.fillText('Start', marginX + 10, canvas.height - marginY - data.y[0] * yScale - 10); // Peak label ctx.textAlign = 'center'; ctx.fillText( `Peak: ${data.maxHeight.toFixed(2)}m`, marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale - 10 ); // Range label ctx.textAlign = 'right'; ctx.fillText( `Range: ${data.range.toFixed(2)}m`, marginX + data.x[data.x.length - 1] * xScale - 10, canvas.height - marginY - data.y[data.y.length - 1] * yScale - 10 ); } // Draw range vs angle chart function drawRangeVsAngleChart(data) { const canvas = rangeAngleCanvas; const ctx = rangeCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xScale = plotWidth / 90; const yScale = plotHeight / (data.maxRange * 1.1); // X axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Launch Angle (degrees)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Range (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= 90; x += 15) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(x.toString(), xPos, canvas.height - marginY + 15); } // Y axis values const yStep = data.maxRange / 5; for (let y = 0; y <= data.maxRange; y += yStep) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw chart ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; for (let i = 0; i < data.angles.length; i++) { const xPos = marginX + data.angles[i] * xScale; const yPos = canvas.height - marginY - data.ranges[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Mark maximum point const maxXPos = marginX + data.maxAngle * xScale; const maxYPos = canvas.height - marginY - data.maxRange * yScale; ctx.beginPath(); ctx.fillStyle = '#2980b9'; ctx.arc(maxXPos, maxYPos, 5, 0, 2 * Math.PI); ctx.fill(); // Maximum label ctx.font = '12px Arial'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.fillText( `Max Range: ${data.maxRange.toFixed(2)}m at ${data.maxAngle.toFixed(1)}\u00b0`, maxXPos, maxYPos - 10 ); } // Run simulation function runSimulation() { // Get parameters const v0 = parseFloat(initialVelocitySlider.value); const angle = parseFloat(launchAngleSlider.value); const gravity = parseFloat(gravitySlider.value); const height = parseFloat(initialHeightSlider.value); const airResistance = parseFloat(airResistanceSlider.value); // Calculate trajectory const trajData = calculateTrajectory(v0, angle, gravity, height, airResistance); // Update metrics rangeValue.textContent = trajData.range.toFixed(2); maxHeightValue.textContent = trajData.maxHeight.toFixed(2); timeValue.textContent = trajData.flightTime.toFixed(2); // Draw trajectory graph drawTrajectory(trajData); // Calculate and draw range vs angle chart const rangeAngleData = generateRangeVsAngleChart(v0, gravity, height); drawRangeVsAngleChart(rangeAngleData); // Update optimal angle info if (height === 0 && airResistance === 0) { optimalAngleInfo.textContent = \"Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0.\"; } else if (height > 0 && airResistance === 0) { optimalAngleInfo.textContent = \"With initial height, the optimal launch angle for maximum range is slightly less than 45\u00b0.\"; } else if (airResistance > 0) { optimalAngleInfo.textContent = \"With air resistance, the optimal launch angle is typically less than 45\u00b0 and depends on the projectile's properties.\"; } } // Simulate button click event simulateBtn.addEventListener('click', runSimulation); // Run initial simulation when page loads window.addEventListener('load', runSimulation);","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-equations-of-motion","text":"Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Deriving Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\]","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#factors-affecting-range","text":"Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) .","title":"Factors Affecting Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation","text":"","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Projectile Motion Analysis 1. Theoretical Foundation Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 2. Simulation Example Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$ Trajectory Table Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74 3. Optional: Interactive Simulation Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; } Forced Damped Pendulum Simulation and Analysis Simulation Parameters Damping Coefficient (\u03b3) 0.50 Driving Amplitude (A) 1.20 Driving Frequency (\u03c9) 0.67 Natural Frequency (\u03c9\u2080) 1.00 Initial Angle (\u03b8\u2080) 0.20 Initial Angular Velocity (\u03b8\u0307\u2080) 0.00 Run Simulation Pendulum Visualization d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) This simulation demonstrates the behavior of a forced damped pendulum. Adjust the parameters to observe how the pendulum responds under different conditions, from periodic motion to chaotic behavior. Angular Displacement vs Time Shows how the pendulum angle changes over time, revealing periodic or chaotic patterns. Phase Space Plots angular velocity against angle, showing the system's overall dynamic behavior. Poincar\u00e9 Section Samples the phase space at regular intervals synchronized with the driving force, revealing long-term behavior patterns and potential chaos. \u00a9 2025 Physics Simulation Project // Get DOM elements const pendulumCanvas = document.getElementById('pendulum-canvas'); const timeChart = document.getElementById('time-chart'); const phaseChart = document.getElementById('phase-chart'); const poincareChart = document.getElementById('poincare-chart'); const runBtn = document.getElementById('run-btn'); // Set up canvas contexts const pendulumCtx = pendulumCanvas.getContext('2d'); const timeCtx = timeChart.getContext('2d'); const phaseCtx = phaseChart.getContext('2d'); const poincareCtx = poincareChart.getContext('2d'); // Set proper canvas sizes function setupCanvases() { // Set pendulum canvas size pendulumCanvas.width = pendulumCanvas.offsetWidth; pendulumCanvas.height = pendulumCanvas.offsetHeight; // Set chart canvas sizes timeChart.width = timeChart.offsetWidth; timeChart.height = timeChart.offsetHeight; phaseChart.width = phaseChart.offsetWidth; phaseChart.height = phaseChart.offsetHeight; poincareChart.width = poincareChart.offsetWidth; poincareChart.height = poincareChart.offsetHeight; } // Call setupCanvases when the page loads and on window resize window.addEventListener('load', setupCanvases); window.addEventListener('resize', setupCanvases); // Simulation parameters let gamma = 0.5; // damping coefficient let A = 1.2; // driving amplitude let omega = 0.67; // driving frequency let omega0 = 1.0; // natural frequency let theta0 = 0.2; // initial angle let thetaDot0 = 0.0; // initial angular velocity // Connect sliders to values document.getElementById('gamma').addEventListener('input', function() { gamma = parseFloat(this.value); document.getElementById('gamma-value').textContent = gamma.toFixed(2); }); document.getElementById('amplitude').addEventListener('input', function() { A = parseFloat(this.value); document.getElementById('amplitude-value').textContent = A.toFixed(2); }); document.getElementById('omega').addEventListener('input', function() { omega = parseFloat(this.value); document.getElementById('omega-value').textContent = omega.toFixed(2); }); document.getElementById('omega0').addEventListener('input', function() { omega0 = parseFloat(this.value); document.getElementById('omega0-value').textContent = omega0.toFixed(2); }); document.getElementById('theta0').addEventListener('input', function() { theta0 = parseFloat(this.value); document.getElementById('theta0-value').textContent = theta0.toFixed(2); }); document.getElementById('thetaDot0').addEventListener('input', function() { thetaDot0 = parseFloat(this.value); document.getElementById('thetaDot0-value').textContent = thetaDot0.toFixed(2); }); // Simulation data let simData = []; let poincareData = []; let animationId = null; // ODE for pendulum function pendulumODE(t, theta, thetaDot) { // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) return -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); } // RK4 method for solving ODEs function rungeKutta4(t, theta, thetaDot, dt) { const k1_v = thetaDot; const k1_a = pendulumODE(t, theta, thetaDot); const k2_v = thetaDot + k1_a * dt/2; const k2_a = pendulumODE(t + dt/2, theta + k1_v * dt/2, thetaDot + k1_a * dt/2); const k3_v = thetaDot + k2_a * dt/2; const k3_a = pendulumODE(t + dt/2, theta + k2_v * dt/2, thetaDot + k2_a * dt/2); const k4_v = thetaDot + k3_a * dt; const k4_a = pendulumODE(t + dt, theta + k3_v * dt, thetaDot + k3_a * dt); const new_theta = theta + (dt/6) * (k1_v + 2*k2_v + 2*k3_v + k4_v); const new_thetaDot = thetaDot + (dt/6) * (k1_a + 2*k2_a + 2*k3_a + k4_a); return [new_theta, new_thetaDot]; } // Run simulation function runSimulation() { // Cancel any previous animation if (animationId) { cancelAnimationFrame(animationId); } // Reset data simData = []; poincareData = []; // Initial conditions let t = 0; let theta = theta0; let thetaDot = thetaDot0; const dt = 0.05; const simLength = 100; // seconds // Period of driving force const T = 2 * Math.PI / omega; let nextPoincareTime = T; // Generate simulation data while (t < simLength) { // Save current state simData.push({t, theta, thetaDot}); // Check if we should record a Poincar\u00e9 point if (t >= nextPoincareTime) { poincareData.push({t, theta, thetaDot}); nextPoincareTime += T; } // Calculate next state [theta, thetaDot] = rungeKutta4(t, theta, thetaDot, dt); // Normalize theta to be between -\u03c0 and \u03c0 theta = ((theta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; // Increment time t += dt; } // Start visualization drawCharts(); startPendulumAnimation(); } // Draw the time series chart function drawTimeChart() { timeCtx.clearRect(0, 0, timeChart.width, timeChart.height); // Draw axes const padding = 30; const width = timeChart.width; const height = timeChart.height; timeCtx.strokeStyle = '#aaa'; timeCtx.lineWidth = 1; // x-axis timeCtx.beginPath(); timeCtx.moveTo(padding, height/2); timeCtx.lineTo(width - padding, height/2); timeCtx.stroke(); // y-axis timeCtx.beginPath(); timeCtx.moveTo(padding, padding); timeCtx.lineTo(padding, height - padding); timeCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); const maxTime = simData[simData.length - 1].t; // Draw the time series timeCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = padding + (width - 2 * padding) * (simData[i].t / maxTime); const y = height/2 - simData[i].theta * 50; if (i === 0) { timeCtx.moveTo(x, y); } else { timeCtx.lineTo(x, y); } } timeCtx.strokeStyle = '#4c6ef5'; timeCtx.lineWidth = 2; timeCtx.stroke(); } // Draw the phase space chart function drawPhaseChart() { phaseCtx.clearRect(0, 0, phaseChart.width, phaseChart.height); // Draw axes const padding = 30; const width = phaseChart.width; const height = phaseChart.height; phaseCtx.strokeStyle = '#aaa'; phaseCtx.lineWidth = 1; // x-axis phaseCtx.beginPath(); phaseCtx.moveTo(padding, height/2); phaseCtx.lineTo(width - padding, height/2); phaseCtx.stroke(); // y-axis phaseCtx.beginPath(); phaseCtx.moveTo(width/2, padding); phaseCtx.lineTo(width/2, height - padding); phaseCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); // Draw the phase space trajectory phaseCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = width/2 + simData[i].theta * 50; const y = height/2 - simData[i].thetaDot * 30; if (i === 0) { phaseCtx.moveTo(x, y); } else { phaseCtx.lineTo(x, y); } } phaseCtx.strokeStyle = '#e64980'; phaseCtx.lineWidth = 2; phaseCtx.stroke(); } // Draw the Poincar\u00e9 section function drawPoincareChart() { poincareCtx.clearRect(0, 0, poincareChart.width, poincareChart.height); // Draw axes const padding = 30; const width = poincareChart.width; const height = poincareChart.height; poincareCtx.strokeStyle = '#aaa'; poincareCtx.lineWidth = 1; // x-axis poincareCtx.beginPath(); poincareCtx.moveTo(padding, height/2); poincareCtx.lineTo(width - padding, height/2); poincareCtx.stroke(); // y-axis poincareCtx.beginPath(); poincareCtx.moveTo(width/2, padding); poincareCtx.lineTo(width/2, height - padding); poincareCtx.stroke(); // Draw Poincar\u00e9 points for (const point of poincareData) { const x = width/2 + point.theta * 50; const y = height/2 - point.thetaDot * 30; poincareCtx.beginPath(); poincareCtx.arc(x, y, 3, 0, 2*Math.PI); poincareCtx.fillStyle = '#7950f2'; poincareCtx.fill(); } } // Draw all charts function drawCharts() { drawTimeChart(); drawPhaseChart(); drawPoincareChart(); } // Animate the pendulum function startPendulumAnimation() { let frameIndex = 0; const framesPerDataPoint = 2; function drawPendulum() { // Clear canvas pendulumCtx.clearRect(0, 0, pendulumCanvas.width, pendulumCanvas.height); // Get dimensions const width = pendulumCanvas.width; const height = pendulumCanvas.height; const centerX = width / 2; const centerY = height / 3; // Length of pendulum const pendulumLength = height / 2; // Get current state const dataIndex = Math.floor(frameIndex / framesPerDataPoint) % simData.length; const currentTheta = simData[dataIndex].theta; // Calculate pendulum position const bobX = centerX + pendulumLength * Math.sin(currentTheta); const bobY = centerY + pendulumLength * Math.cos(currentTheta); // Draw pivot pendulumCtx.beginPath(); pendulumCtx.arc(centerX, centerY, 5, 0, 2*Math.PI); pendulumCtx.fillStyle = '#333'; pendulumCtx.fill(); // Draw rod pendulumCtx.beginPath(); pendulumCtx.moveTo(centerX, centerY); pendulumCtx.lineTo(bobX, bobY); pendulumCtx.strokeStyle = '#555'; pendulumCtx.lineWidth = 2; pendulumCtx.stroke(); // Draw bob pendulumCtx.beginPath(); pendulumCtx.arc(bobX, bobY, 15, 0, 2*Math.PI); pendulumCtx.fillStyle = '#4c6ef5'; pendulumCtx.fill(); // Increment frame counter frameIndex++; // Request next frame animationId = requestAnimationFrame(drawPendulum); } // Start animation drawPendulum(); } // Run simulation button click handler runBtn.addEventListener('click', runSimulation); // Run the simulation when the page loads window.addEventListener('load', function() { setTimeout(runSimulation, 500); }); 4. Conclusion Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-simulation-example","text":"Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$","title":"2. Simulation Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#trajectory-table","text":"Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74","title":"Trajectory Table"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-optional-interactive-simulation","text":"Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; }","title":"3. Optional: Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-conclusion","text":"Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"4. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Problem 3 - Orbital Period and Orbital Radius Simulation 1. Motivation The relationship between the orbital period and orbital radius, known as Kepler's Third Law , connects planetary motion with gravitational theory. It is expressed as: \\[ T^2 \\propto R^3 \\] Where: - \\(T\\) is the orbital period - \\(R\\) is the orbital radius This simulation explores this relationship in circular orbits using Newtonian gravitation and centripetal force. 2. Theoretical Foundation Using Newton's Law of Gravitation and circular motion: Gravitational Force: $$ F = \\frac{GMm}{R^2} $$ Centripetal Force: $$ F = \\frac{mv^2}{R} $$ Setting the two equal: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity: \\[ v = \\sqrt{\\frac{GM}{R}} \\] Orbital period is: \\[ T = \\frac{2\\pi R}{v} = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] Thus, proving Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM} R^3 \\] 3. Simulation Code Kepler's Third Law body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fa; color: #333; line-height: 1.6; max-width: 1000px; margin: 0 auto; } h1, h2 { color: #2c3e50; text-align: center; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin: 20px 0; } .chart-container { position: relative; height: 400px; margin: 20px 0; } .info { background-color: #f0f4f8; padding: 15px; border-radius: 5px; margin: 20px 0; } .data-table { width: 100%; border-collapse: collapse; margin: 20px 0; } .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: center; } .data-table th { background-color: #f2f2f2; } .data-table tr:nth-child(even) { background-color: #f9f9f9; } .formula { text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; padding: 10px; background-color: #edf2f7; border-radius: 5px; } .footnote { margin-top: 30px; font-size: 0.9em; color: #666; text-align: center; } .planet-orbit { width: 100%; height: 300px; margin: 20px 0; } Kepler's Third Law - Orbital Period vs Radius Kepler's Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit around the Sun. This is expressed as: T\u00b2 \u221d R\u00b3, or more precisely: T = 2\u03c0\u221a(R\u00b3/GM) Where: T is the orbital period R is the semi-major axis of the orbit (or radius for circular orbits) G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) M is the mass of the Sun (1.989 \u00d7 10\u00b3\u2070 kg) Orbital Periods of Inner Planets Planet Orbital Radius (millions km) Orbital Period (days) T\u00b2/R\u00b3 (constant) \u00a9 2025 Astronomical Simulation | Created with HTML, CSS, and JavaScript // Constants const G = 6.67430e-11; // gravitational constant const M = 1.989e30; // mass of the Sun (kg) // Orbital radii in meters const radii = [5.79e10, 1.08e11, 1.50e11, 2.28e11]; const planetLabels = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"]; // Calculate periods using T = 2pi * sqrt(R^3 / GM) const periods = radii.map(r => 2 * Math.PI * Math.sqrt(Math.pow(r, 3) / (G * M))); const periodsDays = periods.map(p => p / (60 * 60 * 24)); // Calculate Kepler constant (T^2/R^3) const keplerConstants = radii.map((r, i) => { const T = periods[i]; return Math.pow(T, 2) / Math.pow(r, 3); }); // Convert radii to millions of km for display const radiiMillionsKm = radii.map(r => (r / 1e9).toFixed(2)); // Populate the data table const tableBody = document.getElementById('planetData'); for (let i = 0; i < planetLabels.length; i++) { const row = document.createElement('tr'); const planetCell = document.createElement('td'); planetCell.textContent = planetLabels[i]; row.appendChild(planetCell); const radiusCell = document.createElement('td'); radiusCell.textContent = radiiMillionsKm[i]; row.appendChild(radiusCell); const periodCell = document.createElement('td'); periodCell.textContent = periodsDays[i].toFixed(2); row.appendChild(periodCell); const constantCell = document.createElement('td'); constantCell.textContent = keplerConstants[i].toExponential(5); row.appendChild(constantCell); tableBody.appendChild(row); } // Create the chart const ctx = document.getElementById('keplerChart').getContext('2d'); const chart = new Chart(ctx, { type: 'scatter', data: { datasets: [{ label: 'Planets', data: radii.map((r, i) => ({ x: r, y: periodsDays[i] })), backgroundColor: 'rgba(75, 192, 192, 0.8)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1, pointRadius: 6, pointHoverRadius: 8 }, { label: 'Kepler\\'s Law Curve', data: generateKeplerCurve(), borderColor: 'rgba(153, 102, 255, 0.7)', backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 2, pointRadius: 0, type: 'line', showLine: true }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Orbital Radius (m)' }, ticks: { callback: function(value) { return (value / 1e10).toFixed(1) + ' \u00d7 10\u00b9\u2070'; } } }, y: { title: { display: true, text: 'Orbital Period (days)' } } }, plugins: { tooltip: { callbacks: { label: function(context) { const index = context.dataIndex; return planetLabels[index] + ' - Radius: ' + radiiMillionsKm[index] + ' million km, Period: ' + periodsDays[index].toFixed(2) + ' days'; } } }, legend: { display: true, position: 'top' } } } }); // Generate points for Kepler's law curve function generateKeplerCurve() { const points = []; const numPoints = 100; const minRadius = 4e10; const maxRadius = 2.5e11; for (let i = 0; i < numPoints; i++) { const r = minRadius + (maxRadius - minRadius) * (i / (numPoints - 1)); const period = 2 * Math.PI * Math.sqrt(Math.pow(r, 3) / (G * M)); const periodDays = period / (60 * 60 * 24); points.push({ x: r, y: periodDays }); } return points; } // Draw the orbit visualization function drawOrbits() { const canvas = document.getElementById('orbitVisualization'); const ctx = canvas.getContext('2d'); // Set canvas dimensions canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; const width = canvas.width; const height = canvas.height; const centerX = width / 2; const centerY = height / 2; // Clear canvas ctx.clearRect(0, 0, width, height); // Define colors for planets const colors = ['#888', '#e6b800', '#3973ac', '#c1440e']; // Scale the orbits to fit the canvas const maxRadius = Math.max(...radii); const scale = (Math.min(width, height) * 0.42) / maxRadius; // Draw Sun ctx.beginPath(); ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI); ctx.fillStyle = '#FDB813'; ctx.fill(); // Draw orbits and planets for (let i = 0; i < radii.length; i++) { const radius = radii[i] * scale; // Draw orbit ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)'; ctx.stroke(); // Calculate planet position (different angle for each planet) const angle = (i * Math.PI / 2) % (2 * Math.PI); const x = centerX + radius * Math.cos(angle); const y = centerY + radius * Math.sin(angle); // Draw planet ctx.beginPath(); ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fillStyle = colors[i]; ctx.fill(); // Add label ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(planetLabels[i], x, y - 12); } } // Run the orbital visualization when the page loads window.addEventListener('load', drawOrbits); window.addEventListener('resize', drawOrbits); 4. Results & Discussion This simulation confirms: The square of the orbital period grows with the cube of the radius. The plotted data aligns with Kepler's Third Law prediction. Real planets like Earth and Mars fit well into the curve. You can extend this model for: - Elliptical orbits - Moons around planets - Exoplanet systems","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-3-orbital-period-and-orbital-radius-simulation","text":"","title":"Problem 3 - Orbital Period and Orbital Radius Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-motivation","text":"The relationship between the orbital period and orbital radius, known as Kepler's Third Law , connects planetary motion with gravitational theory. It is expressed as: \\[ T^2 \\propto R^3 \\] Where: - \\(T\\) is the orbital period - \\(R\\) is the orbital radius This simulation explores this relationship in circular orbits using Newtonian gravitation and centripetal force.","title":"1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-theoretical-foundation","text":"Using Newton's Law of Gravitation and circular motion: Gravitational Force: $$ F = \\frac{GMm}{R^2} $$ Centripetal Force: $$ F = \\frac{mv^2}{R} $$ Setting the two equal: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity: \\[ v = \\sqrt{\\frac{GM}{R}} \\] Orbital period is: \\[ T = \\frac{2\\pi R}{v} = 2\\pi \\sqrt{\\frac{R^3}{GM}} \\] Thus, proving Kepler's Third Law: \\[ T^2 = \\frac{4\\pi^2}{GM} R^3 \\]","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-simulation-code","text":"Kepler's Third Law body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fa; color: #333; line-height: 1.6; max-width: 1000px; margin: 0 auto; } h1, h2 { color: #2c3e50; text-align: center; } .container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin: 20px 0; } .chart-container { position: relative; height: 400px; margin: 20px 0; } .info { background-color: #f0f4f8; padding: 15px; border-radius: 5px; margin: 20px 0; } .data-table { width: 100%; border-collapse: collapse; margin: 20px 0; } .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: center; } .data-table th { background-color: #f2f2f2; } .data-table tr:nth-child(even) { background-color: #f9f9f9; } .formula { text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; padding: 10px; background-color: #edf2f7; border-radius: 5px; } .footnote { margin-top: 30px; font-size: 0.9em; color: #666; text-align: center; } .planet-orbit { width: 100%; height: 300px; margin: 20px 0; }","title":"3. Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-results-discussion","text":"This simulation confirms: The square of the orbital period grows with the cube of the radius. The plotted data aligns with Kepler's Third Law prediction. Real planets like Earth and Mars fit well into the curve. You can extend this model for: - Elliptical orbits - Moons around planets - Exoplanet systems","title":"4. Results &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2 - Escape & Cosmic Velocities Simulation This simulation compares the first (orbital), second (escape), and third (solar system escape) cosmic velocities for three celestial bodies: Earth, Mars, and Jupiter. It uses classical Newtonian mechanics and visualizes the results with a bar chart and a data table. To view the simulation, open docs/Problem_2/sim/index.html Key Equations 1st Cosmic Velocity (Orbital): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ 2nd Cosmic Velocity (Escape): $$ v_2 = \\sqrt{2} \\cdot v_1 $$ 3rd Cosmic Velocity (Solar Escape): $$ v_3 = v_2 + v_{\\text{solar}} $$ (Solar velocity for Earth \u2248 42.1 km/s) ## Simulation Escape & Cosmic Velocities Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f9fbfd; color: #333; margin: 0; padding: 20px; max-width: 1200px; margin: auto; } h1, h2 { text-align: center; color: #2c3e50; } .container { background: #fff; padding: 30px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-top: 20px; } canvas { width: 100%; max-width: 800px; margin: 20px auto; display: block; } table { width: 100%; border-collapse: collapse; margin-top: 30px; } th, td { border: 1px solid #ddd; padding: 10px; text-align: center; } th { background: #f0f4f8; } .note { font-size: 0.9em; color: #555; text-align: center; margin-top: 40px; } Escape & Cosmic Velocities Velocity Comparison for Celestial Bodies Planet 1st Cosmic (Orbital) Velocity (km/s) 2nd Cosmic (Escape) Velocity (km/s) 3rd Cosmic (Solar System Escape) (km/s) Based on standard values for mass and radius. Calculated using classical Newtonian mechanics. const G = 6.67430e-11; const solarVelocity = 42.1; // km/s from Earth reference const bodies = [ { name: \"Earth\", mass: 5.972e24, radius: 6371000 }, { name: \"Mars\", mass: 6.417e23, radius: 3389500 }, { name: \"Jupiter\", mass: 1.898e27, radius: 69911000 } ]; const tableBody = document.getElementById(\"velocityTable\"); const chartData = { labels: [], datasets: [ { label: \"1st Cosmic Velocity\", data: [], backgroundColor: \"#4c6ef5\" }, { label: \"2nd Cosmic Velocity\", data: [], backgroundColor: \"#82c91e\" }, { label: \"3rd Cosmic Velocity\", data: [], backgroundColor: \"#f59f00\" } ] }; bodies.forEach(body => { const v1 = Math.sqrt(G * body.mass / body.radius) / 1000; const v2 = Math.sqrt(2) * v1; const v3 = v2 + solarVelocity; chartData.labels.push(body.name); chartData.datasets[0].data.push(v1); chartData.datasets[1].data.push(v2); chartData.datasets[2].data.push(v3); const row = ` <tr> <td>${body.name}</td> <td>${v1.toFixed(2)}</td> <td>${v2.toFixed(2)}</td> <td>${v3.toFixed(2)}</td> </tr> `; tableBody.innerHTML += row; }); new Chart(document.getElementById(\"velocityChart\"), { type: \"bar\", data: chartData, options: { responsive: true, plugins: { legend: { position: \"top\" }, title: { display: true, text: \"Cosmic Velocities (km/s)\" } }, scales: { y: { title: { display: true, text: \"Velocity (km/s)\" } } } } });","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-cosmic-velocities-simulation","text":"This simulation compares the first (orbital), second (escape), and third (solar system escape) cosmic velocities for three celestial bodies: Earth, Mars, and Jupiter. It uses classical Newtonian mechanics and visualizes the results with a bar chart and a data table. To view the simulation, open docs/Problem_2/sim/index.html","title":"Problem 2 - Escape &amp; Cosmic Velocities Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-equations","text":"1st Cosmic Velocity (Orbital): $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ 2nd Cosmic Velocity (Escape): $$ v_2 = \\sqrt{2} \\cdot v_1 $$ 3rd Cosmic Velocity (Solar Escape): $$ v_3 = v_2 + v_{\\text{solar}} $$ (Solar velocity for Earth \u2248 42.1 km/s) ## Simulation Escape & Cosmic Velocities Simulation body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f9fbfd; color: #333; margin: 0; padding: 20px; max-width: 1200px; margin: auto; } h1, h2 { text-align: center; color: #2c3e50; } .container { background: #fff; padding: 30px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-top: 20px; } canvas { width: 100%; max-width: 800px; margin: 20px auto; display: block; } table { width: 100%; border-collapse: collapse; margin-top: 30px; } th, td { border: 1px solid #ddd; padding: 10px; text-align: center; } th { background: #f0f4f8; } .note { font-size: 0.9em; color: #555; text-align: center; margin-top: 40px; }","title":"Key Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}