{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis 1. Theoretical Foundation Deriving Equations of Motion Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\] Family of Solutions Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges. 2. Analysis of the Range The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Factors Affecting Range Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) . 3. Practical Applications Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity. 4. Implementation Simulation Simulation Parameters Initial Velocity (m/s): 20 Launch Angle (degrees): 45 Gravity (m/s\u00b2): 9.81 Initial Height (m): 0 Air Resistance Coefficient: 0 Run Simulation 0.00 Range (m) 0.00 Max Height (m) 0.00 Flight Time (s) Trajectory Visualization Range vs. Launch Angle Analysis Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0. // Get DOM elements const initialVelocitySlider = document.getElementById('initial-velocity'); const launchAngleSlider = document.getElementById('launch-angle'); const gravitySlider = document.getElementById('gravity'); const initialHeightSlider = document.getElementById('initial-height'); const airResistanceSlider = document.getElementById('air-resistance'); const velocityValue = document.getElementById('velocity-value'); const angleValue = document.getElementById('angle-value'); const gravityValue = document.getElementById('gravity-value'); const heightValue = document.getElementById('height-value'); const resistanceValue = document.getElementById('resistance-value'); const rangeValue = document.getElementById('range-value'); const maxHeightValue = document.getElementById('max-height-value'); const timeValue = document.getElementById('time-value'); const simulateBtn = document.getElementById('simulate-btn'); const trajectoryCanvas = document.getElementById('trajectory-canvas'); const rangeAngleCanvas = document.getElementById('range-angle-canvas'); const optimalAngleInfo = document.getElementById('optimal-angle-info'); // Canvas setup const trajCtx = trajectoryCanvas.getContext('2d'); const rangeCtx = rangeAngleCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { trajectoryCanvas.width = trajectoryCanvas.clientWidth; trajectoryCanvas.height = trajectoryCanvas.clientHeight; rangeAngleCanvas.width = rangeAngleCanvas.clientWidth; rangeAngleCanvas.height = rangeAngleCanvas.clientHeight; } window.addEventListener('resize', resizeCanvas); resizeCanvas(); // Display slider values initialVelocitySlider.addEventListener('input', () => { velocityValue.textContent = initialVelocitySlider.value; }); launchAngleSlider.addEventListener('input', () => { angleValue.textContent = launchAngleSlider.value; }); gravitySlider.addEventListener('input', () => { gravityValue.textContent = parseFloat(gravitySlider.value).toFixed(2); }); initialHeightSlider.addEventListener('input', () => { heightValue.textContent = initialHeightSlider.value; }); airResistanceSlider.addEventListener('input', () => { resistanceValue.textContent = parseFloat(airResistanceSlider.value).toFixed(2); }); // Simulation calculations function calculateTrajectory(v0, angle, gravity, height, airResistance) { // Convert angle to radians const angleRad = angle * Math.PI / 180; // Initial velocities const vx0 = v0 * Math.cos(angleRad); const vy0 = v0 * Math.sin(angleRad); let flightTime; let x = []; let y = []; // Calculate flight time (analytical solution without air resistance) if (airResistance === 0) { flightTime = (vy0 + Math.sqrt(vy0 * vy0 + 2 * gravity * height)) / gravity; // Handle very small angles with initial height if (angle < 0.1 && height > 0) { flightTime = (2 * vy0) / gravity + Math.sqrt(2 * height / gravity); } // Time steps for trajectory const timeSteps = 1000; const dt = flightTime / timeSteps; // Analytical calculation for (let i = 0; i <= timeSteps; i++) { const t = i * dt; x.push(vx0 * t); y.push(height + vy0 * t - 0.5 * gravity * t * t); // Stop if we hit the ground if (y[i] < 0) { y[i] = 0; x = x.slice(0, i + 1); y = y.slice(0, i + 1); break; } } } else { // Numerical calculation with air resistance const dt = 0.01; let t = 0; let yPos = height; let xPos = 0; let vx = vx0; let vy = vy0; while (yPos >= 0) { // Update velocities vx = vx - airResistance * vx * dt; vy = vy - gravity * dt - airResistance * vy * dt; // Update position xPos = xPos + vx * dt; yPos = yPos + vy * dt; x.push(xPos); y.push(yPos); t += dt; // Avoid infinite loops or extremely long calculations if (t > 100 || xPos > 10000) break; } flightTime = t; // Fix the last point if (y[y.length - 1] < 0) { y[y.length - 1] = 0; } } // Calculate range const horizontalRange = x[x.length - 1]; // Calculate maximum height let maxHeight = height; for (let i = 0; i < y.length; i++) { if (y[i] > maxHeight) { maxHeight = y[i]; } } return { x: x, y: y, range: horizontalRange, maxHeight: maxHeight, flightTime: flightTime }; } // Generate range vs angle chart function generateRangeVsAngleChart(v0, gravity, height) { const angles = []; const ranges = []; // Calculate range for each angle for (let angle = 0; angle <= 90; angle += 1) { angles.push(angle); const traj = calculateTrajectory(v0, angle, gravity, height, 0); ranges.push(traj.range); } // Find maximum range let maxRange = 0; let maxAngle = 0; for (let i = 0; i < ranges.length; i++) { if (ranges[i] > maxRange) { maxRange = ranges[i]; maxAngle = angles[i]; } } return { angles: angles, ranges: ranges, maxRange: maxRange, maxAngle: maxAngle }; } // Draw trajectory graph function drawTrajectory(data) { const canvas = trajectoryCanvas; const ctx = trajCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xMax = Math.max(...data.x) * 1.1; const yMax = Math.max(data.maxHeight * 1.2, 10); const xScale = plotWidth / xMax; const yScale = plotHeight / yMax; // Ground line ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Horizontal Distance (m)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Height (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= xMax; x += xMax / 5) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(Math.round(x).toString(), xPos, canvas.height - marginY + 15); } // Y axis values for (let y = 0; y <= yMax; y += yMax / 5) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw trajectory ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; for (let i = 0; i < data.x.length; i++) { const xPos = marginX + data.x[i] * xScale; const yPos = canvas.height - marginY - data.y[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Starting point ctx.beginPath(); ctx.fillStyle = '#e74c3c'; ctx.arc(marginX, canvas.height - marginY - data.y[0] * yScale, 5, 0, 2 * Math.PI); ctx.fill(); // Highest point const maxHeightIndex = data.y.indexOf(data.maxHeight); const maxHeightX = data.x[maxHeightIndex]; ctx.beginPath(); ctx.fillStyle = '#27ae60'; ctx.arc( marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Landing point ctx.beginPath(); ctx.fillStyle = '#9b59b6'; ctx.arc( marginX + data.x[data.x.length - 1] * xScale, canvas.height - marginY - data.y[data.y.length - 1] * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Labels ctx.font = '12px Arial'; ctx.fillStyle = '#333'; // Start label ctx.textAlign = 'left'; ctx.fillText('Start', marginX + 10, canvas.height - marginY - data.y[0] * yScale - 10); // Peak label ctx.textAlign = 'center'; ctx.fillText( `Peak: ${data.maxHeight.toFixed(2)}m`, marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale - 10 ); // Range label ctx.textAlign = 'right'; ctx.fillText( `Range: ${data.range.toFixed(2)}m`, marginX + data.x[data.x.length - 1] * xScale - 10, canvas.height - marginY - data.y[data.y.length - 1] * yScale - 10 ); } // Draw range vs angle chart function drawRangeVsAngleChart(data) { const canvas = rangeAngleCanvas; const ctx = rangeCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xScale = plotWidth / 90; const yScale = plotHeight / (data.maxRange * 1.1); // X axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Launch Angle (degrees)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Range (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= 90; x += 15) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(x.toString(), xPos, canvas.height - marginY + 15); } // Y axis values const yStep = data.maxRange / 5; for (let y = 0; y <= data.maxRange; y += yStep) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw chart ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; for (let i = 0; i < data.angles.length; i++) { const xPos = marginX + data.angles[i] * xScale; const yPos = canvas.height - marginY - data.ranges[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Mark maximum point const maxXPos = marginX + data.maxAngle * xScale; const maxYPos = canvas.height - marginY - data.maxRange * yScale; ctx.beginPath(); ctx.fillStyle = '#2980b9'; ctx.arc(maxXPos, maxYPos, 5, 0, 2 * Math.PI); ctx.fill(); // Maximum label ctx.font = '12px Arial'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.fillText( `Max Range: ${data.maxRange.toFixed(2)}m at ${data.maxAngle.toFixed(1)}\u00b0`, maxXPos, maxYPos - 10 ); } // Run simulation function runSimulation() { // Get parameters const v0 = parseFloat(initialVelocitySlider.value); const angle = parseFloat(launchAngleSlider.value); const gravity = parseFloat(gravitySlider.value); const height = parseFloat(initialHeightSlider.value); const airResistance = parseFloat(airResistanceSlider.value); // Calculate trajectory const trajData = calculateTrajectory(v0, angle, gravity, height, airResistance); // Update metrics rangeValue.textContent = trajData.range.toFixed(2); maxHeightValue.textContent = trajData.maxHeight.toFixed(2); timeValue.textContent = trajData.flightTime.toFixed(2); // Draw trajectory graph drawTrajectory(trajData); // Calculate and draw range vs angle chart const rangeAngleData = generateRangeVsAngleChart(v0, gravity, height); drawRangeVsAngleChart(rangeAngleData); // Update optimal angle info if (height === 0 && airResistance === 0) { optimalAngleInfo.textContent = \"Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0.\"; } else if (height > 0 && airResistance === 0) { optimalAngleInfo.textContent = \"With initial height, the optimal launch angle for maximum range is slightly less than 45\u00b0.\"; } else if (airResistance > 0) { optimalAngleInfo.textContent = \"With air resistance, the optimal launch angle is typically less than 45\u00b0 and depends on the projectile's properties.\"; } } // Simulate button click event simulateBtn.addEventListener('click', runSimulation); // Run initial simulation when page loads window.addEventListener('load', runSimulation);","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-equations-of-motion","text":"Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Deriving Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\]","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#factors-affecting-range","text":"Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) .","title":"Factors Affecting Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation","text":"","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Projectile Motion Analysis 1. Theoretical Foundation Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 2. Simulation Example Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$ Trajectory Table Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74 3. Optional: Interactive Simulation Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; } Forced Damped Pendulum Simulation and Analysis Simulation Parameters Damping Coefficient (\u03b3) 0.50 Driving Amplitude (A) 1.20 Driving Frequency (\u03c9) 0.67 Natural Frequency (\u03c9\u2080) 1.00 Initial Angle (\u03b8\u2080) 0.20 Initial Angular Velocity (\u03b8\u0307\u2080) 0.00 Run Simulation Pendulum Visualization d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) This simulation demonstrates the behavior of a forced damped pendulum. Adjust the parameters to observe how the pendulum responds under different conditions, from periodic motion to chaotic behavior. Angular Displacement vs Time Shows how the pendulum angle changes over time, revealing periodic or chaotic patterns. Phase Space Plots angular velocity against angle, showing the system's overall dynamic behavior. Poincar\u00e9 Section Samples the phase space at regular intervals synchronized with the driving force, revealing long-term behavior patterns and potential chaos. \u00a9 2025 Physics Simulation Project // Get DOM elements const pendulumCanvas = document.getElementById('pendulum-canvas'); const timeChart = document.getElementById('time-chart'); const phaseChart = document.getElementById('phase-chart'); const poincareChart = document.getElementById('poincare-chart'); const runBtn = document.getElementById('run-btn'); // Set up canvas contexts const pendulumCtx = pendulumCanvas.getContext('2d'); const timeCtx = timeChart.getContext('2d'); const phaseCtx = phaseChart.getContext('2d'); const poincareCtx = poincareChart.getContext('2d'); // Set proper canvas sizes function setupCanvases() { // Set pendulum canvas size pendulumCanvas.width = pendulumCanvas.offsetWidth; pendulumCanvas.height = pendulumCanvas.offsetHeight; // Set chart canvas sizes timeChart.width = timeChart.offsetWidth; timeChart.height = timeChart.offsetHeight; phaseChart.width = phaseChart.offsetWidth; phaseChart.height = phaseChart.offsetHeight; poincareChart.width = poincareChart.offsetWidth; poincareChart.height = poincareChart.offsetHeight; } // Call setupCanvases when the page loads and on window resize window.addEventListener('load', setupCanvases); window.addEventListener('resize', setupCanvases); // Simulation parameters let gamma = 0.5; // damping coefficient let A = 1.2; // driving amplitude let omega = 0.67; // driving frequency let omega0 = 1.0; // natural frequency let theta0 = 0.2; // initial angle let thetaDot0 = 0.0; // initial angular velocity // Connect sliders to values document.getElementById('gamma').addEventListener('input', function() { gamma = parseFloat(this.value); document.getElementById('gamma-value').textContent = gamma.toFixed(2); }); document.getElementById('amplitude').addEventListener('input', function() { A = parseFloat(this.value); document.getElementById('amplitude-value').textContent = A.toFixed(2); }); document.getElementById('omega').addEventListener('input', function() { omega = parseFloat(this.value); document.getElementById('omega-value').textContent = omega.toFixed(2); }); document.getElementById('omega0').addEventListener('input', function() { omega0 = parseFloat(this.value); document.getElementById('omega0-value').textContent = omega0.toFixed(2); }); document.getElementById('theta0').addEventListener('input', function() { theta0 = parseFloat(this.value); document.getElementById('theta0-value').textContent = theta0.toFixed(2); }); document.getElementById('thetaDot0').addEventListener('input', function() { thetaDot0 = parseFloat(this.value); document.getElementById('thetaDot0-value').textContent = thetaDot0.toFixed(2); }); // Simulation data let simData = []; let poincareData = []; let animationId = null; // ODE for pendulum function pendulumODE(t, theta, thetaDot) { // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) return -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); } // RK4 method for solving ODEs function rungeKutta4(t, theta, thetaDot, dt) { const k1_v = thetaDot; const k1_a = pendulumODE(t, theta, thetaDot); const k2_v = thetaDot + k1_a * dt/2; const k2_a = pendulumODE(t + dt/2, theta + k1_v * dt/2, thetaDot + k1_a * dt/2); const k3_v = thetaDot + k2_a * dt/2; const k3_a = pendulumODE(t + dt/2, theta + k2_v * dt/2, thetaDot + k2_a * dt/2); const k4_v = thetaDot + k3_a * dt; const k4_a = pendulumODE(t + dt, theta + k3_v * dt, thetaDot + k3_a * dt); const new_theta = theta + (dt/6) * (k1_v + 2*k2_v + 2*k3_v + k4_v); const new_thetaDot = thetaDot + (dt/6) * (k1_a + 2*k2_a + 2*k3_a + k4_a); return [new_theta, new_thetaDot]; } // Run simulation function runSimulation() { // Cancel any previous animation if (animationId) { cancelAnimationFrame(animationId); } // Reset data simData = []; poincareData = []; // Initial conditions let t = 0; let theta = theta0; let thetaDot = thetaDot0; const dt = 0.05; const simLength = 100; // seconds // Period of driving force const T = 2 * Math.PI / omega; let nextPoincareTime = T; // Generate simulation data while (t < simLength) { // Save current state simData.push({t, theta, thetaDot}); // Check if we should record a Poincar\u00e9 point if (t >= nextPoincareTime) { poincareData.push({t, theta, thetaDot}); nextPoincareTime += T; } // Calculate next state [theta, thetaDot] = rungeKutta4(t, theta, thetaDot, dt); // Normalize theta to be between -\u03c0 and \u03c0 theta = ((theta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; // Increment time t += dt; } // Start visualization drawCharts(); startPendulumAnimation(); } // Draw the time series chart function drawTimeChart() { timeCtx.clearRect(0, 0, timeChart.width, timeChart.height); // Draw axes const padding = 30; const width = timeChart.width; const height = timeChart.height; timeCtx.strokeStyle = '#aaa'; timeCtx.lineWidth = 1; // x-axis timeCtx.beginPath(); timeCtx.moveTo(padding, height/2); timeCtx.lineTo(width - padding, height/2); timeCtx.stroke(); // y-axis timeCtx.beginPath(); timeCtx.moveTo(padding, padding); timeCtx.lineTo(padding, height - padding); timeCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); const maxTime = simData[simData.length - 1].t; // Draw the time series timeCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = padding + (width - 2 * padding) * (simData[i].t / maxTime); const y = height/2 - simData[i].theta * 50; if (i === 0) { timeCtx.moveTo(x, y); } else { timeCtx.lineTo(x, y); } } timeCtx.strokeStyle = '#4c6ef5'; timeCtx.lineWidth = 2; timeCtx.stroke(); } // Draw the phase space chart function drawPhaseChart() { phaseCtx.clearRect(0, 0, phaseChart.width, phaseChart.height); // Draw axes const padding = 30; const width = phaseChart.width; const height = phaseChart.height; phaseCtx.strokeStyle = '#aaa'; phaseCtx.lineWidth = 1; // x-axis phaseCtx.beginPath(); phaseCtx.moveTo(padding, height/2); phaseCtx.lineTo(width - padding, height/2); phaseCtx.stroke(); // y-axis phaseCtx.beginPath(); phaseCtx.moveTo(width/2, padding); phaseCtx.lineTo(width/2, height - padding); phaseCtx.stroke(); // Skip points to avoid too many data points const skip = Math.max(1, Math.floor(simData.length / 200)); // Draw the phase space trajectory phaseCtx.beginPath(); for (let i = 0; i < simData.length; i += skip) { const x = width/2 + simData[i].theta * 50; const y = height/2 - simData[i].thetaDot * 30; if (i === 0) { phaseCtx.moveTo(x, y); } else { phaseCtx.lineTo(x, y); } } phaseCtx.strokeStyle = '#e64980'; phaseCtx.lineWidth = 2; phaseCtx.stroke(); } // Draw the Poincar\u00e9 section function drawPoincareChart() { poincareCtx.clearRect(0, 0, poincareChart.width, poincareChart.height); // Draw axes const padding = 30; const width = poincareChart.width; const height = poincareChart.height; poincareCtx.strokeStyle = '#aaa'; poincareCtx.lineWidth = 1; // x-axis poincareCtx.beginPath(); poincareCtx.moveTo(padding, height/2); poincareCtx.lineTo(width - padding, height/2); poincareCtx.stroke(); // y-axis poincareCtx.beginPath(); poincareCtx.moveTo(width/2, padding); poincareCtx.lineTo(width/2, height - padding); poincareCtx.stroke(); // Draw Poincar\u00e9 points for (const point of poincareData) { const x = width/2 + point.theta * 50; const y = height/2 - point.thetaDot * 30; poincareCtx.beginPath(); poincareCtx.arc(x, y, 3, 0, 2*Math.PI); poincareCtx.fillStyle = '#7950f2'; poincareCtx.fill(); } } // Draw all charts function drawCharts() { drawTimeChart(); drawPhaseChart(); drawPoincareChart(); } // Animate the pendulum function startPendulumAnimation() { let frameIndex = 0; const framesPerDataPoint = 2; function drawPendulum() { // Clear canvas pendulumCtx.clearRect(0, 0, pendulumCanvas.width, pendulumCanvas.height); // Get dimensions const width = pendulumCanvas.width; const height = pendulumCanvas.height; const centerX = width / 2; const centerY = height / 3; // Length of pendulum const pendulumLength = height / 2; // Get current state const dataIndex = Math.floor(frameIndex / framesPerDataPoint) % simData.length; const currentTheta = simData[dataIndex].theta; // Calculate pendulum position const bobX = centerX + pendulumLength * Math.sin(currentTheta); const bobY = centerY + pendulumLength * Math.cos(currentTheta); // Draw pivot pendulumCtx.beginPath(); pendulumCtx.arc(centerX, centerY, 5, 0, 2*Math.PI); pendulumCtx.fillStyle = '#333'; pendulumCtx.fill(); // Draw rod pendulumCtx.beginPath(); pendulumCtx.moveTo(centerX, centerY); pendulumCtx.lineTo(bobX, bobY); pendulumCtx.strokeStyle = '#555'; pendulumCtx.lineWidth = 2; pendulumCtx.stroke(); // Draw bob pendulumCtx.beginPath(); pendulumCtx.arc(bobX, bobY, 15, 0, 2*Math.PI); pendulumCtx.fillStyle = '#4c6ef5'; pendulumCtx.fill(); // Increment frame counter frameIndex++; // Request next frame animationId = requestAnimationFrame(drawPendulum); } // Start animation drawPendulum(); } // Run simulation button click handler runBtn.addEventListener('click', runSimulation); // Run the simulation when the page loads window.addEventListener('load', function() { setTimeout(runSimulation, 500); }); 4. Conclusion Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Projectile motion is a form of motion experienced by an object that is launched into the air and influenced only by gravity. We split the motion into two components: Horizontal motion: constant velocity $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: uniformly accelerated motion $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-simulation-example","text":"Initial conditions: Initial velocity: $$ v_0 = 20\\, \\text{m/s} $$ Angle: $$ \\theta = 45^\\circ $$ Gravity: $$ g = 9.81\\, \\text{m/s}^2 $$","title":"2. Simulation Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#trajectory-table","text":"Time (s) X (m) Y (m) 0.0 0.00 0.00 0.5 7.07 6.02 1.0 14.14 9.82 1.5 21.21 11.39 2.0 28.28 10.73 2.5 35.35 7.85 3.0 42.42 2.74","title":"Trajectory Table"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-optional-interactive-simulation","text":"Forced Damped Pendulum Simulator body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7f9; color: #333; line-height: 1.6; max-width: 1200px; margin: 0 auto; } h1, h2, h3 { color: #2c3e50; margin-top: 1.5em; } h1 { text-align: center; margin-bottom: 1em; padding-bottom: 0.5em; border-bottom: 1px solid #eaeaea; } .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 2em; } .simulation-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 600px; } .controls-container { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; flex: 1; min-width: 300px; max-width: 400px; } .simulation-view { position: relative; height: 300px; overflow: hidden; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 1em; background-color: #f8f9fa; } #pendulum-canvas { width: 100%; height: 100%; } .control-group { margin-bottom: 15px; } label { display: block; font-weight: 600; margin-bottom: 5px; color: #555; } .value-display { float: right; font-weight: 400; color: #666; } input[type=\"range\"] { width: 100%; margin: 8px 0; } button { background-color: #4c6ef5; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 15px; transition: background-color 0.2s; } button:hover { background-color:rgb(7, 148, 98); } .chart-row { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; } .chart-box { flex: 1; min-width: 300px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; } .chart { width: 100%; height: 200px; border: 1px solid #e1e4e8; border-radius: 4px; margin-bottom: 10px; background-color: #f8f9fa; } .equation { background-color: #f0f4f8; padding: 15px; border-radius: 5px; text-align: center; margin: 20px 0; font-family: 'Cambria Math', Georgia, serif; font-size: 18px; } .footnote { margin-top: 2em; font-size: 0.9em; color: #666; text-align: center; }","title":"3. Optional: Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-conclusion","text":"Projectile motion can be analyzed easily using basic trigonometry and kinematic equations. This problem demonstrates the use of physics formulas to predict real-world behavior.","title":"4. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}