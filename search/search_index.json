{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis 1. Theoretical Foundation Deriving Equations of Motion Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\] Family of Solutions Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges. 2. Analysis of the Range The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Factors Affecting Range Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) . 3. Practical Applications Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity. 4. Implementation Simulation Simulation Parameters Initial Velocity (m/s): 20 Launch Angle (degrees): 45 Gravity (m/s\u00b2): 9.81 Initial Height (m): 0 Air Resistance Coefficient: 0 Run Simulation 0.00 Range (m) 0.00 Max Height (m) 0.00 Flight Time (s) Trajectory Visualization Range vs. Launch Angle Analysis Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0. // Get DOM elements const initialVelocitySlider = document.getElementById('initial-velocity'); const launchAngleSlider = document.getElementById('launch-angle'); const gravitySlider = document.getElementById('gravity'); const initialHeightSlider = document.getElementById('initial-height'); const airResistanceSlider = document.getElementById('air-resistance'); const velocityValue = document.getElementById('velocity-value'); const angleValue = document.getElementById('angle-value'); const gravityValue = document.getElementById('gravity-value'); const heightValue = document.getElementById('height-value'); const resistanceValue = document.getElementById('resistance-value'); const rangeValue = document.getElementById('range-value'); const maxHeightValue = document.getElementById('max-height-value'); const timeValue = document.getElementById('time-value'); const simulateBtn = document.getElementById('simulate-btn'); const trajectoryCanvas = document.getElementById('trajectory-canvas'); const rangeAngleCanvas = document.getElementById('range-angle-canvas'); const optimalAngleInfo = document.getElementById('optimal-angle-info'); // Canvas setup const trajCtx = trajectoryCanvas.getContext('2d'); const rangeCtx = rangeAngleCanvas.getContext('2d'); // Set canvas size function resizeCanvas() { trajectoryCanvas.width = trajectoryCanvas.clientWidth; trajectoryCanvas.height = trajectoryCanvas.clientHeight; rangeAngleCanvas.width = rangeAngleCanvas.clientWidth; rangeAngleCanvas.height = rangeAngleCanvas.clientHeight; } window.addEventListener('resize', resizeCanvas); resizeCanvas(); // Display slider values initialVelocitySlider.addEventListener('input', () => { velocityValue.textContent = initialVelocitySlider.value; }); launchAngleSlider.addEventListener('input', () => { angleValue.textContent = launchAngleSlider.value; }); gravitySlider.addEventListener('input', () => { gravityValue.textContent = parseFloat(gravitySlider.value).toFixed(2); }); initialHeightSlider.addEventListener('input', () => { heightValue.textContent = initialHeightSlider.value; }); airResistanceSlider.addEventListener('input', () => { resistanceValue.textContent = parseFloat(airResistanceSlider.value).toFixed(2); }); // Simulation calculations function calculateTrajectory(v0, angle, gravity, height, airResistance) { // Convert angle to radians const angleRad = angle * Math.PI / 180; // Initial velocities const vx0 = v0 * Math.cos(angleRad); const vy0 = v0 * Math.sin(angleRad); let flightTime; let x = []; let y = []; // Calculate flight time (analytical solution without air resistance) if (airResistance === 0) { flightTime = (vy0 + Math.sqrt(vy0 * vy0 + 2 * gravity * height)) / gravity; // Handle very small angles with initial height if (angle < 0.1 && height > 0) { flightTime = (2 * vy0) / gravity + Math.sqrt(2 * height / gravity); } // Time steps for trajectory const timeSteps = 1000; const dt = flightTime / timeSteps; // Analytical calculation for (let i = 0; i <= timeSteps; i++) { const t = i * dt; x.push(vx0 * t); y.push(height + vy0 * t - 0.5 * gravity * t * t); // Stop if we hit the ground if (y[i] < 0) { y[i] = 0; x = x.slice(0, i + 1); y = y.slice(0, i + 1); break; } } } else { // Numerical calculation with air resistance const dt = 0.01; let t = 0; let yPos = height; let xPos = 0; let vx = vx0; let vy = vy0; while (yPos >= 0) { // Update velocities vx = vx - airResistance * vx * dt; vy = vy - gravity * dt - airResistance * vy * dt; // Update position xPos = xPos + vx * dt; yPos = yPos + vy * dt; x.push(xPos); y.push(yPos); t += dt; // Avoid infinite loops or extremely long calculations if (t > 100 || xPos > 10000) break; } flightTime = t; // Fix the last point if (y[y.length - 1] < 0) { y[y.length - 1] = 0; } } // Calculate range const horizontalRange = x[x.length - 1]; // Calculate maximum height let maxHeight = height; for (let i = 0; i < y.length; i++) { if (y[i] > maxHeight) { maxHeight = y[i]; } } return { x: x, y: y, range: horizontalRange, maxHeight: maxHeight, flightTime: flightTime }; } // Generate range vs angle chart function generateRangeVsAngleChart(v0, gravity, height) { const angles = []; const ranges = []; // Calculate range for each angle for (let angle = 0; angle <= 90; angle += 1) { angles.push(angle); const traj = calculateTrajectory(v0, angle, gravity, height, 0); ranges.push(traj.range); } // Find maximum range let maxRange = 0; let maxAngle = 0; for (let i = 0; i < ranges.length; i++) { if (ranges[i] > maxRange) { maxRange = ranges[i]; maxAngle = angles[i]; } } return { angles: angles, ranges: ranges, maxRange: maxRange, maxAngle: maxAngle }; } // Draw trajectory graph function drawTrajectory(data) { const canvas = trajectoryCanvas; const ctx = trajCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xMax = Math.max(...data.x) * 1.1; const yMax = Math.max(data.maxHeight * 1.2, 10); const xScale = plotWidth / xMax; const yScale = plotHeight / yMax; // Ground line ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Horizontal Distance (m)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Height (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= xMax; x += xMax / 5) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(Math.round(x).toString(), xPos, canvas.height - marginY + 15); } // Y axis values for (let y = 0; y <= yMax; y += yMax / 5) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw trajectory ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 2; for (let i = 0; i < data.x.length; i++) { const xPos = marginX + data.x[i] * xScale; const yPos = canvas.height - marginY - data.y[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Starting point ctx.beginPath(); ctx.fillStyle = '#e74c3c'; ctx.arc(marginX, canvas.height - marginY - data.y[0] * yScale, 5, 0, 2 * Math.PI); ctx.fill(); // Highest point const maxHeightIndex = data.y.indexOf(data.maxHeight); const maxHeightX = data.x[maxHeightIndex]; ctx.beginPath(); ctx.fillStyle = '#27ae60'; ctx.arc( marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Landing point ctx.beginPath(); ctx.fillStyle = '#9b59b6'; ctx.arc( marginX + data.x[data.x.length - 1] * xScale, canvas.height - marginY - data.y[data.y.length - 1] * yScale, 5, 0, 2 * Math.PI ); ctx.fill(); // Labels ctx.font = '12px Arial'; ctx.fillStyle = '#333'; // Start label ctx.textAlign = 'left'; ctx.fillText('Start', marginX + 10, canvas.height - marginY - data.y[0] * yScale - 10); // Peak label ctx.textAlign = 'center'; ctx.fillText( `Peak: ${data.maxHeight.toFixed(2)}m`, marginX + maxHeightX * xScale, canvas.height - marginY - data.maxHeight * yScale - 10 ); // Range label ctx.textAlign = 'right'; ctx.fillText( `Range: ${data.range.toFixed(2)}m`, marginX + data.x[data.x.length - 1] * xScale - 10, canvas.height - marginY - data.y[data.y.length - 1] * yScale - 10 ); } // Draw range vs angle chart function drawRangeVsAngleChart(data) { const canvas = rangeAngleCanvas; const ctx = rangeCtx; // Clear canvas ctx.clearRect(0, 0, canvas.width, canvas.height); // Margins for coordinate system const marginX = 50; const marginY = 50; // Available area const plotWidth = canvas.width - 2 * marginX; const plotHeight = canvas.height - 2 * marginY; // X and Y scales const xScale = plotWidth / 90; const yScale = plotHeight / (data.maxRange * 1.1); // X axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX + plotWidth, canvas.height - marginY); ctx.stroke(); // Y axis ctx.beginPath(); ctx.strokeStyle = '#999'; ctx.moveTo(marginX, canvas.height - marginY); ctx.lineTo(marginX, marginY); ctx.stroke(); // Axis labels ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Launch Angle (degrees)', canvas.width / 2, canvas.height - 10); ctx.save(); ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.textAlign = 'center'; ctx.fillText('Range (m)', 0, 0); ctx.restore(); // X axis values for (let x = 0; x <= 90; x += 15) { const xPos = marginX + x * xScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(xPos, canvas.height - marginY); ctx.lineTo(xPos, marginY); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText(x.toString(), xPos, canvas.height - marginY + 15); } // Y axis values const yStep = data.maxRange / 5; for (let y = 0; y <= data.maxRange; y += yStep) { const yPos = canvas.height - marginY - y * yScale; ctx.beginPath(); ctx.strokeStyle = '#ddd'; ctx.moveTo(marginX, yPos); ctx.lineTo(marginX + plotWidth, yPos); ctx.stroke(); ctx.fillStyle = '#666'; ctx.textAlign = 'right'; ctx.fillText(Math.round(y).toString(), marginX - 5, yPos + 4); } // Draw chart ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2; for (let i = 0; i < data.angles.length; i++) { const xPos = marginX + data.angles[i] * xScale; const yPos = canvas.height - marginY - data.ranges[i] * yScale; if (i === 0) { ctx.moveTo(xPos, yPos); } else { ctx.lineTo(xPos, yPos); } } ctx.stroke(); // Mark maximum point const maxXPos = marginX + data.maxAngle * xScale; const maxYPos = canvas.height - marginY - data.maxRange * yScale; ctx.beginPath(); ctx.fillStyle = '#2980b9'; ctx.arc(maxXPos, maxYPos, 5, 0, 2 * Math.PI); ctx.fill(); // Maximum label ctx.font = '12px Arial'; ctx.fillStyle = '#333'; ctx.textAlign = 'center'; ctx.fillText( `Max Range: ${data.maxRange.toFixed(2)}m at ${data.maxAngle.toFixed(1)}\u00b0`, maxXPos, maxYPos - 10 ); } // Run simulation function runSimulation() { // Get parameters const v0 = parseFloat(initialVelocitySlider.value); const angle = parseFloat(launchAngleSlider.value); const gravity = parseFloat(gravitySlider.value); const height = parseFloat(initialHeightSlider.value); const airResistance = parseFloat(airResistanceSlider.value); // Calculate trajectory const trajData = calculateTrajectory(v0, angle, gravity, height, airResistance); // Update metrics rangeValue.textContent = trajData.range.toFixed(2); maxHeightValue.textContent = trajData.maxHeight.toFixed(2); timeValue.textContent = trajData.flightTime.toFixed(2); // Draw trajectory graph drawTrajectory(trajData); // Calculate and draw range vs angle chart const rangeAngleData = generateRangeVsAngleChart(v0, gravity, height); drawRangeVsAngleChart(rangeAngleData); // Update optimal angle info if (height === 0 && airResistance === 0) { optimalAngleInfo.textContent = \"Without air resistance and starting at ground level, the optimal launch angle for maximum range is exactly 45\u00b0.\"; } else if (height > 0 && airResistance === 0) { optimalAngleInfo.textContent = \"With initial height, the optimal launch angle for maximum range is slightly less than 45\u00b0.\"; } else if (airResistance > 0) { optimalAngleInfo.textContent = \"With air resistance, the optimal launch angle is typically less than 45\u00b0 and depends on the projectile's properties.\"; } } // Simulate button click event simulateBtn.addEventListener('click', runSimulation); // Run initial simulation when page loads window.addEventListener('load', runSimulation);","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-equations-of-motion","text":"Projectile motion follows Newton\u2019s second law: \\[ F = ma \\] For a projectile launched with initial velocity \\( v_0 \\) at an angle \\( \\theta \\) , we decompose motion into horizontal and vertical components: Horizontal: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical: \\(v_{0y} = v_0 \\sin\\theta\\) Using kinematic equations: \\[ x(t) = v_{0x} t \\] \\[ y(t) = v_{0y} t - \\frac{1}{2} g t^2 \\] To find the time of flight: \\[ t_f = \\frac{2 v_{0y}}{g} = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Deriving Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Varying initial velocity and angle results in different trajectories, forming a family of solutions characterized by different maximum heights and ranges.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) is given by: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\]","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#factors-affecting-range","text":"Increasing \\(v_0\\) increases \\(R\\) quadratically. Maximum range occurs at \\(theta = 45^\\circ\\) . Increasing \\(g\\) (e.g., on different planets) decreases \\(R\\) .","title":"Factors Affecting Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Ballistics : Optimizing projectile launch angles for artillery. Sports : Calculating optimal angles for throwing a ball. Rocket Launches : Adjusting for air resistance and varying gravity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulation","text":"","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 pendulumPhysics.ts /** Forced Damped Pendulum Physics Module This module implements the physics for a forced damped pendulum, which is a non-linear system that can exhibit chaotic behavior under certain conditions. The pendulum is described by the differential equation: d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) Where: \u03b8 is the angular displacement \u03b3 is the damping coefficient \u03c9\u2080 is the natural frequency A is the driving amplitude \u03c9 is the driving frequency / export interface PendulumPoint { t: number; // time theta: number; // angle thetaDot: number; // angular velocity } export interface PendulumResult { points: PendulumPoint[]; poincarePoints: PendulumPoint[]; params: PendulumParameters; } export interface PendulumParameters { gamma: number; // damping coefficient A: number; // driving amplitude omega: number; // driving frequency omega0: number; // natural frequency theta0: number; // initial angle thetaDot0: number; // initial angular velocity tMax: number; // simulation time dt: number; // time step } export const defaultParams: PendulumParameters = { gamma: 0.5, A: 1.2, omega: 0.67, omega0: 1.0, theta0: 0.2, thetaDot0: 0.0, tMax: 100, dt: 0.05 }; / * The pendulum ODE function. Given the current state and parameters, computes the derivatives. Returns [d\u03b8/dt, d\u00b2\u03b8/dt\u00b2] */ function pendulumODE(t: number, y: [number, number], params: PendulumParameters): [number, number] { const [theta, thetaDot] = y; const { gamma, A, omega, omega0 } = params; // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) const thetaDotDot = -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); return [thetaDot, thetaDotDot]; } /* * Runge-Kutta 4th order method for solving the pendulum ODE. * * This is a numerical method for solving ordinary differential equations. / function rk4Step(t: number, y: [number, number], dt: number, params: PendulumParameters): [number, number] { const k1 = pendulumODE(t, y, params); const y2: [number, number] = [ y[0] + k1[0] * dt / 2, y[1] + k1[1] * dt / 2 ]; const k2 = pendulumODE(t + dt / 2, y2, params); const y3: [number, number] = [ y[0] + k2[0] * dt / 2, y[1] + k2[1] * dt / 2 ]; const k3 = pendulumODE(t + dt / 2, y3, params); const y4: [number, number] = [ y[0] + k3[0] * dt, y[1] + k3[1] * dt ]; const k4 = pendulumODE(t + dt, y4, params); return [ y[0] + (dt / 6) * (k1[0] + 2 * k2[0] + 2 * k3[0] + k4[0]), y[1] + (dt / 6) * (k1[1] + 2 * k2[1] + 2 * k3[1] + k4[1]) ]; } /* * Solve the pendulum differential equation and return the result. * * This function generates both the full trajectory and the Poincar\u00e9 section, * which samples the phase space at intervals of the driving period. / export function solvePendulum(params: PendulumParameters): PendulumResult { const { theta0, thetaDot0, tMax, dt, omega } = params; // Initialize state let t = 0; let theta = theta0; let thetaDot = thetaDot0; const points: PendulumPoint[] = []; const poincarePoints: PendulumPoint[] = []; // The driving period const T = 2 * Math.PI / omega; // Time for next Poincar\u00e9 section let nextPoincareTime = T; // Add initial point points.push({ t, theta, thetaDot }); // Main integration loop while (t < tMax) { // Calculate next state using RK4 const [newTheta, newThetaDot] = rk4Step(t, [theta, thetaDot], dt, params); // Update time t += dt; // Normalize theta to [-\u03c0, \u03c0] theta = ((newTheta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; thetaDot = newThetaDot; // Add point to trajectory points.push({ t, theta, thetaDot }); // Check if we should add a point to the Poincar\u00e9 section if (t >= nextPoincareTime) { poincarePoints.push({ t, theta, thetaDot }); nextPoincareTime += T; } } return { points, poincarePoints, params }; } 2. PendulumSimulator.tsx import { useState, useCallback, useEffect } from \"react\"; import SimulationControls from \"./SimulationControls\"; import AngularDisplacementChart from \"./AngularDisplacementChart\"; import PhaseSpaceChart from \"./PhaseSpaceChart\"; import PoincareChart from \"./PoincareChart\"; import { solvePendulum, PendulumParameters, PendulumResult, defaultParams } from \"./pendulumPhysics\"; export default function PendulumSimulator() { // State for simulation parameters and results const [parameters, setParameters] = useState (defaultParams); const [simulationData, setSimulationData] = useState (null); const [loading, setLoading] = useState(false); // Handle parameter changes from controls const handleParametersChange = useCallback((newParams: PendulumParameters) => { setParameters(newParams); }, []); // Run simulation with current parameters const runSimulation = useCallback(() => { setLoading(true); // Use setTimeout to prevent UI freezing during computation setTimeout(() => { try { const result = solvePendulum(parameters); setSimulationData(result); } catch (error) { console.error(\"Simulation error:\", error); alert(\"An error occurred during simulation.\"); } finally { setLoading(false); } }, 10); }, [parameters]); // Run initial simulation on mount useEffect(() => { runSimulation(); }, []); return ( Forced Damped Pendulum Simulation Interactive simulation of a forced damped pendulum described by the differential equation: d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) {/ Control Panel /} Simulation Parameters {/* Charts */} <div className=\"md:w-2/3 space-y-6\"> {loading ? ( <div className=\"flex items-center justify-center h-64 bg-white rounded-lg shadow-md\"> <p className=\"text-lg\">Calculating simulation... This may take a moment</p> </div> ) : ( <> <AngularDisplacementChart simulationData={simulationData} /> <div className=\"grid md:grid-cols-2 gap-6\"> <PhaseSpaceChart simulationData={simulationData} /> <PoincareChart simulationData={simulationData} /> </div> <div className=\"bg-white rounded-lg shadow-md p-6\"> <h2 className=\"text-xl font-semibold mb-3\">Equations & Theory</h2> <div className=\"text-sm space-y-2\"> <p> <strong>Differential Equation:</strong> <span className=\"block font-mono my-1\">d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t)</span> </p> <div> <strong>Parameters:</strong> <ul className=\"ml-5 list-disc\"> <li>\u03b3 (gamma): Damping coefficient</li> <li>\u03c9\u2080 (omega0): Natural frequency</li> <li>A: Driving amplitude</li> <li>\u03c9 (omega): Driving frequency</li> </ul> </div> <p> <strong>Phase Space:</strong> Shows the relationship between angle (\u03b8) and angular velocity (\u03b8\u0307). The trajectory in phase space can reveal patterns in the pendulum's behavior. </p> <p> <strong>Poincar\u00e9 Section:</strong> Samples the phase space at regular intervals synchronized with the driving force, revealing the long-term behavior and potential chaos. </p> </div> </div> )} </div> </div> </div> ); } 3. SimulationControls.tsx import { useState, useEffect } from 'react'; import { PendulumParameters, defaultParams } from './pendulumPhysics'; interface SimulationControlsProps { onParametersChange: (params: PendulumParameters) => void; onSimulate: () => void; } export default function SimulationControls({ onParametersChange, onSimulate }: SimulationControlsProps) { const [params, setParams] = useState ({...defaultParams}); useEffect(() => { onParametersChange(params); }, [params, onParametersChange]); const handleInputChange = (e: React.ChangeEvent ) => { const { name, value } = e.target; const numValue = parseFloat(value); if (!isNaN(numValue)) { setParams(prevParams => ({ ...prevParams, [name]: numValue })); } }; const handleSliderChange = (name: keyof PendulumParameters, value: number) => { setParams(prevParams => ({ ...prevParams, [name]: value })); }; return ( {/ Damping Coefficient (gamma) /} Damping Coefficient (\u03b3) {params.gamma.toFixed(2)} handleSliderChange(\"gamma\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Driving Amplitude (A) /} Driving Amplitude (A) {params.A.toFixed(2)} handleSliderChange(\"A\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Driving Frequency (omega) /} Driving Frequency (\u03c9) {params.omega.toFixed(2)} handleSliderChange(\"omega\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Natural Frequency (omega0) /} Natural Frequency (\u03c9\u2080) {params.omega0.toFixed(2)} handleSliderChange(\"omega0\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Initial Angle (theta0) /} Initial Angle (\u03b8\u2080) {params.theta0.toFixed(2)} handleSliderChange(\"theta0\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Initial Angular Velocity (thetaDot0) /} Initial Angular Velocity (\u03b8\u0307\u2080) {params.thetaDot0.toFixed(2)} handleSliderChange(\"thetaDot0\", parseFloat(e.target.value))} className=\"w-full\" /> {/ Run Simulation Button /} Run Simulation ); } 4. AngularDisplacementChart.tsx import { useEffect, useRef } from 'react'; import { PendulumResult } from './pendulumPhysics'; import { Chart, registerables } from 'chart.js'; // Register Chart.js components Chart.register(...registerables); interface AngularDisplacementChartProps { simulationData: PendulumResult | null; } export default function AngularDisplacementChart({ simulationData }: AngularDisplacementChartProps) { const chartRef = useRef (null); const chartInstance = useRef (null); useEffect(() => { if (!simulationData || !chartRef.current) return; // Destroy previous chart instance if it exists if (chartInstance.current) { chartInstance.current.destroy(); } // Get every nth point to avoid too many points const stride = Math.max(1, Math.floor(simulationData.points.length / 500)); const filteredPoints = simulationData.points.filter((_, i) => i % stride === 0); // Create new chart const ctx = chartRef.current.getContext('2d'); if (!ctx) return; chartInstance.current = new Chart(ctx, { type: 'line', data: { labels: filteredPoints.map(p => p.t.toFixed(1)), datasets: [{ label: 'Angular Displacement (\u03b8)', data: filteredPoints.map(p => p.theta), borderColor: 'rgb(75, 192, 192)', backgroundColor: 'rgba(75, 192, 192, 0.5)', tension: 0.2, }] }, options: { responsive: true, plugins: { legend: { position: 'top', }, title: { display: true, text: 'Angular Displacement Over Time', }, }, scales: { x: { title: { display: true, text: 'Time (s)' } }, y: { title: { display: true, text: 'Angle (rad)' } } } } }); // Cleanup function return () => { if (chartInstance.current) { chartInstance.current.destroy(); } }; }, [simulationData]); return ( Angular Displacement Over Time ); } 5. PhaseSpaceChart.tsx import { useEffect, useRef } from 'react'; import { PendulumResult } from './pendulumPhysics'; import { Chart, registerables } from 'chart.js'; // Register Chart.js components Chart.register(...registerables); interface PhaseSpaceChartProps { simulationData: PendulumResult | null; } export default function PhaseSpaceChart({ simulationData }: PhaseSpaceChartProps) { const chartRef = useRef (null); const chartInstance = useRef (null); useEffect(() => { if (!simulationData || !chartRef.current) return; // Destroy previous chart instance if it exists if (chartInstance.current) { chartInstance.current.destroy(); } // Sample points to avoid overcrowding const stride = Math.max(1, Math.floor(simulationData.points.length / 200)); const filteredPoints = simulationData.points.filter((_, i) => i % stride === 0); // Create new chart const ctx = chartRef.current.getContext('2d'); if (!ctx) return; chartInstance.current = new Chart(ctx, { type: 'scatter', data: { datasets: [{ label: 'Phase Space', data: filteredPoints.map(p => ({ x: p.theta, // angle y: p.thetaDot // angular velocity })), backgroundColor: 'rgba(255, 99, 132, 0.5)', pointRadius: 2, showLine: true, borderColor: 'rgba(255, 99, 132, 0.8)', borderWidth: 1, }] }, options: { responsive: true, scales: { x: { title: { display: true, text: 'Angle \u03b8 (rad)' }, min: -Math.PI, max: Math.PI }, y: { title: { display: true, text: 'Angular Velocity \u03b8\u0307 (rad/s)' } } }, plugins: { tooltip: { callbacks: { label: function(context: any) { const point = context.raw; return `\u03b8: ${point.x.toFixed(2)}, \u03b8\u0307: ${point.y.toFixed(2)}`; } } }, legend: { display: false } } } }); // Cleanup function return () => { if (chartInstance.current) { chartInstance.current.destroy(); } }; }, [simulationData]); return ( Phase Space Plots angular velocity (\u03b8\u0307) vs. angle (\u03b8), showing system dynamics ); } 6. PoincareChart.tsx import { useEffect, useRef } from 'react'; import { PendulumResult } from './pendulumPhysics'; import { Chart, registerables } from 'chart.js'; // Register Chart.js components Chart.register(...registerables); interface PoincareChartProps { simulationData: PendulumResult | null; } export default function PoincareChart({ simulationData }: PoincareChartProps) { const chartRef = useRef (null); const chartInstance = useRef (null); useEffect(() => { if (!simulationData || !chartRef.current || !simulationData.poincarePoints.length) return; // Destroy previous chart instance if it exists if (chartInstance.current) { chartInstance.current.destroy(); } // Create new chart const ctx = chartRef.current.getContext('2d'); if (!ctx) return; chartInstance.current = new Chart(ctx, { type: 'scatter', data: { datasets: [{ label: 'Poincar\u00e9 Section', data: simulationData.poincarePoints.map(p => ({ x: p.theta, y: p.thetaDot })), backgroundColor: 'rgba(153, 102, 255, 0.6)', pointRadius: 3, pointHoverRadius: 5, showLine: false, }] }, options: { responsive: true, scales: { x: { title: { display: true, text: 'Angle \u03b8 (rad)' }, min: -Math.PI, max: Math.PI }, y: { title: { display: true, text: 'Angular Velocity \u03b8\u0307 (rad/s)' } } }, plugins: { tooltip: { callbacks: { label: function(context: any) { const point = context.raw; return `\u03b8: ${point.x.toFixed(2)}, \u03b8\u0307: ${point.y.toFixed(2)}`; } } }, legend: { display: false } } } }); // Cleanup function return () => { if (chartInstance.current) { chartInstance.current.destroy(); } }; }, [simulationData]); return ( Poincar\u00e9 Section Sample points at driving period intervals reveal chaotic or periodic behavior ); }","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"pendulumPhysics.ts /** Forced Damped Pendulum Physics Module This module implements the physics for a forced damped pendulum, which is a non-linear system that can exhibit chaotic behavior under certain conditions. The pendulum is described by the differential equation: d\u00b2\u03b8/dt\u00b2 + \u03b3\u00b7d\u03b8/dt + \u03c9\u2080\u00b2\u00b7sin(\u03b8) = A\u00b7cos(\u03c9\u00b7t) Where: \u03b8 is the angular displacement \u03b3 is the damping coefficient \u03c9\u2080 is the natural frequency A is the driving amplitude \u03c9 is the driving frequency / export interface PendulumPoint { t: number; // time theta: number; // angle thetaDot: number; // angular velocity } export interface PendulumResult { points: PendulumPoint[]; poincarePoints: PendulumPoint[]; params: PendulumParameters; } export interface PendulumParameters { gamma: number; // damping coefficient A: number; // driving amplitude omega: number; // driving frequency omega0: number; // natural frequency theta0: number; // initial angle thetaDot0: number; // initial angular velocity tMax: number; // simulation time dt: number; // time step } export const defaultParams: PendulumParameters = { gamma: 0.5, A: 1.2, omega: 0.67, omega0: 1.0, theta0: 0.2, thetaDot0: 0.0, tMax: 100, dt: 0.05 }; / * The pendulum ODE function. Given the current state and parameters, computes the derivatives. Returns [d\u03b8/dt, d\u00b2\u03b8/dt\u00b2] */ function pendulumODE(t: number, y: [number, number], params: PendulumParameters): [number, number] { const [theta, thetaDot] = y; const { gamma, A, omega, omega0 } = params; // d\u00b2\u03b8/dt\u00b2 = -\u03b3\u00b7d\u03b8/dt - \u03c9\u2080\u00b2\u00b7sin(\u03b8) + A\u00b7cos(\u03c9t) const thetaDotDot = -gamma * thetaDot - omega0 * omega0 * Math.sin(theta) + A * Math.cos(omega * t); return [thetaDot, thetaDotDot]; } /* * Runge-Kutta 4th order method for solving the pendulum ODE. * * This is a numerical method for solving ordinary differential equations. / function rk4Step(t: number, y: [number, number], dt: number, params: PendulumParameters): [number, number] { const k1 = pendulumODE(t, y, params); const y2: [number, number] = [ y[0] + k1[0] * dt / 2, y[1] + k1[1] * dt / 2 ]; const k2 = pendulumODE(t + dt / 2, y2, params); const y3: [number, number] = [ y[0] + k2[0] * dt / 2, y[1] + k2[1] * dt / 2 ]; const k3 = pendulumODE(t + dt / 2, y3, params); const y4: [number, number] = [ y[0] + k3[0] * dt, y[1] + k3[1] * dt ]; const k4 = pendulumODE(t + dt, y4, params); return [ y[0] + (dt / 6) * (k1[0] + 2 * k2[0] + 2 * k3[0] + k4[0]), y[1] + (dt / 6) * (k1[1] + 2 * k2[1] + 2 * k3[1] + k4[1]) ]; } /* * Solve the pendulum differential equation and return the result. * * This function generates both the full trajectory and the Poincar\u00e9 section, * which samples the phase space at intervals of the driving period. / export function solvePendulum(params: PendulumParameters): PendulumResult { const { theta0, thetaDot0, tMax, dt, omega } = params; // Initialize state let t = 0; let theta = theta0; let thetaDot = thetaDot0; const points: PendulumPoint[] = []; const poincarePoints: PendulumPoint[] = []; // The driving period const T = 2 * Math.PI / omega; // Time for next Poincar\u00e9 section let nextPoincareTime = T; // Add initial point points.push({ t, theta, thetaDot }); // Main integration loop while (t < tMax) { // Calculate next state using RK4 const [newTheta, newThetaDot] = rk4Step(t, [theta, thetaDot], dt, params); // Update time t += dt; // Normalize theta to [-\u03c0, \u03c0] theta = ((newTheta + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI; thetaDot = newThetaDot; // Add point to trajectory points.push({ t, theta, thetaDot }); // Check if we should add a point to the Poincar\u00e9 section if (t >= nextPoincareTime) { poincarePoints.push({ t, theta, thetaDot }); nextPoincareTime += T; } } return { points, poincarePoints, params }; } 2. PendulumSimulator.tsx import { useState, useCallback, useEffect } from \"react\"; import SimulationControls from \"./SimulationControls\"; import AngularDisplacementChart from \"./AngularDisplacementChart\"; import PhaseSpaceChart from \"./PhaseSpaceChart\"; import PoincareChart from \"./PoincareChart\"; import { solvePendulum, PendulumParameters, PendulumResult, defaultParams } from \"./pendulumPhysics\"; export default function PendulumSimulator() { // State for simulation parameters and results const [parameters, setParameters] = useState (defaultParams); const [simulationData, setSimulationData] = useState (null); const [loading, setLoading] = useState(false); // Handle parameter changes from controls const handleParametersChange = useCallback((newParams: PendulumParameters) => { setParameters(newParams); }, []); // Run simulation with current parameters const runSimulation = useCallback(() => { setLoading(true); // Use setTimeout to prevent UI freezing during computation setTimeout(() => { try { const result = solvePendulum(parameters); setSimulationData(result); } catch (error) { console.error(\"Simulation error:\", error); alert(\"An error occurred during simulation.\"); } finally { setLoading(false); } }, 10); }, [parameters]); // Run initial simulation on mount useEffect(() => { runSimulation(); }, []); return (","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}